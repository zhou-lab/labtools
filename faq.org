#+STARTUP: overview
** recent 
*** how to use basic calculator (bc) in unix
-l load standard math library
bc -l <<< "5*7/3"
11.6666
$ result=$(echo "scale=2; 5 * 7 /3;" | bc)
$ echo $result
11.66

*** how to grep from the end of the file?
tac file | grep

*** convert rows to columns

A1
B1
C1

A2
B2
C2

=>
A1 B1 C1
A2 B2 C2

awk 'ORS=(NR%8==0)?"\n":"\t"{print $1}'
wzmanip transpose

*** delete character in line using tr
tr -d "\n"
remove all newline characters.
*** how to sort with header
(head -n 2 <file> && tail -n +3 <file> | sort) > newfile
*** how to extract from string
use expr
http://tldp.org/LDP/abs/html/string-manipulation.html
expr $a : '.*\(Tumor-[0-9]*\).*'
and
http://stackoverflow.com/questions/9597751/using-match-to-find-substrings-in-strings-with-only-bash

use BASH_REMATCH (better, no need to put .* in front and after the regular expression)
[[ $a =~ Tumor-([0-9]*) ]] && echo $BASH_REMATCH

*** convert blank, space to tab
tr -s [:blank:] \\t
*** join lines in a file
perl -ne 'chomp;print;' file
tr -d '\n' < file
awk '{printf $0;}' file
paste -s --delimiters="" file
sed -e :a  -e 'N;s/\n//;ta'  file
*** how to show line end and tab
cat -te
*** how to merge extra blank lines
cat -s
*** how to expand path
readlink -f ~/reference/hs37d5/hs37d5.fa
gives
/scratch/bcb/wzhou1/reference/hs37d5/hs37d5.fa
*** how to print pattern to pattern using sed and awk
sed -n '/StartPattern/,/EndPattern/p' FileName
awk '/StartPattern/,/EndPattern/' FileName
*** how to delete first/last line
delete first line
tail -n +2 "$FILE"
or
sed -i -e "1d" $FILE
or
perl -ni -e 'print unless $. == 1' filename.txt

delete last line
sed -i '$ d' foo.txt
$ means "the last line in the file". When specifying a location (called "range" in sed lingo) before a command, that command is only applied to the specified location. So, this command explicitly says "in the range of the last line in a file, delete it
*** how to print a non-sequential number of lines
$ sed -n -e 1,2p -e 4p somefile.txt
Line 1
Line 2
Line 4
*** how to add some text to a given line
add new text in the first line
sed -e '1s/$/new text/' yourfile.txt 
*** how to remove blank lines
grep -v "^$" file.txt
sed '/^$/d' file.txt
awk '/./' file.txt
tr -s '\n' < file.txt
*** how to add commas and convert column to row
# add commas and print in one line
echo $(awk 'NR > 1{print line", "}{line=$0;}END{print $0" "}' file)
I Love Bash, I Love Bash, I Love Bash
*** print range but exclude patterns
exclude both starting and ending pattern
$ cat file
AIX
Solaris
Unix
Linux
HPUX
$ sed -n '/Solaris/,/HPUX/{//!p;}' file
Unix
Linux

exclude ending pattern
sed -n '/chrM/,/GL000207.1/{/GL000207.1/!p}' /scratch/bcb/wzhou1/reference/hs37d5/hs37d5.fa > hs37d5.fa.chrM
*** how to loop over range of numbers
three expression for loop
for (( EXP1; EXP2; EXP3 )); do command; done

Numerical range (explicit)
for i in 1 2 3 4 5; do command; done

numerical range (implicit) bash 3.0+
for i in {1..5}; do echo "Welcome $i times" done

numerical range (implicit) {START..END..INCREMENT} bash 4.0+
for i in {0..10..2}; do echo "Welcome $i times" done

NOTE: the seq command is outdated. use new version (below)
generate a sequence of numbers
for i in `seq 1 $END`; do echo $i; done
equivalent to
for ((i=1;i<=END;++i)); do echo $i; done
* archive
** git
*** to reduce repo size
git gc --aggressive --prune=now
** bash
*** to grep pattern1 or pattern2
grep 'pattern1\|pattern2' filename
grep -E 'pattern1|pattern2' filename
egrep 'pattern1|pattern2' filename

grep -E option is for extended regexp. If you use the grep command with -E option, you just need to use | to separate multiple patterns for the or condition.
*** to grep pattern1 and pattern2
grep -e pattern1 -e pattern2 filename
*** how to empty/clean a file
清空文件
:>data.xxx
cat /dev/null data.xxx
*** how to know the type of a variable
type something用来看something的类型。比如type test或者type '['
*** how to opens file filename for reading and writing, and assigns file descriptor i to it?
[i]<>filename
*** how to get directory name
dirname
*** how to get the basename of a file path?
There are two ways:
**** using # and % operator
$ x="/foo/fizzbuzz.bar"
$ y=${x%.bar}
$ echo ${y##*/}
${x%.bar} could also be ${x%.*} to remove everything after a dot or ${x%%.*} to remove everything after the first dot.

Example:
$ x="/foo/fizzbuzz.bar.quux"
$ y=${x%.*}
$ echo $y
/foo/fizzbuzz.bar
$ y=${x%%.*}
$ echo $y
/foo/fizzbuzz

**** using "basename"
NAME=`basename /foo/fizzbuzz.bar .bar`
*** common pitfalls
no space between "="
count=2;
not count = 2; (bash would confuse count for a command)

don't pipe to the same file
cat mydata.txt | sort | uniq > mydata.txt
bash would open mydata immediately to remove the original text in mydata.txt

always use "" around a string variable
if [ $var = "yes" ], when $var is empty, bash gets
if [ = "yes"] which is an error.

*** how to tell the location of the bash script file sourced
$(dirname ${BASH_ARGV[0]})

*** to resolve variable
use ${}
#+BEGIN_SRC sh
echo "MySHELL=>$SHELLCODE<="
# will look for variable $SHELLCODE
echo "MySHELL=>${SHELL}CODE<="
# will look for variable $SHELL
#+END_SRC

*** indirect variable referencing with ${!var}
get the value of a value. ${!var}
#+BEGIN_SRC sh
$ a=letter_of_alphabet
$ letter_of_alphabet=z
$ echo "a = $a" # Direct reference
a=letter_of_alphabet
$ echo "Now a = ${!a}" # Indirect reference
a=z
#+END_SRC
The ${!variable} notation is more intuitive than the old eval var1=\$$var2
*** command substitution
**** assign output of a command to a variable
#+BEGIN_SRC sh
var=$(command-name-here)
var=$(command-name-here arg1)
var=$(/path/to/command)
var=$(/path/to/command arg1 arg2)
# or
var=`command-name-here`
var=`command-name-here arg1`
var=`/path/to/command`
var=`/path/to/command arg1 arg2`
#+END_SRC

command substitution can happen directly in echo
#+BEGIN_SRC sh
echo "Today is $(date)"
# or
printf "Today is %s\n" "$(date)"
#+END_SRC
*** brace expansion
echo {a,b}$PATH
is equivalent to
echo a$PATH b$PATH
declare -a 'pics=(img{' "$a..$b" '}.png)'; mv "${pics[@]}" ../imgs
echo {I,want,my,money,back}
echo _{I,want,my,money,back}-
outputs: _I- _want- _my- _money- _back-
echo {5..12}
outputs: 5 6 7 8 9 10 11 12
echo {c..k}
outputs: c d e f g h i j k
echo {01..10}
outputs: 01 02 03 04 05 06 07 08 09 10
echo {A..Z}{0..9}
outputs: A0 A1 ... Z9
this combines the iterations
echo {{A..Z},{a..z}}
outputs: A B ... Z a b ... z
wget http://docs.example.com/documentation/slides_part{1..6}.html
mkdir /home/bash/test/{foo,bar,baz,cat,dog}
for i in 0{1..9} 10; do printf "%s\n" "$i";done
printf "%s\n" img{00{1..9},0{10..99},{100..999}}.png
echo $(printf "img%02d.png " {1..99})
repeat arguments
somecommand -v{,,,,}
outputs: somecommand -v -v -v -v -v
echo {1..10..2}
increment by 2

NOTE that brace expansion ({}, or brace expansion) does not expand variables, so you cannot do {$start .. $end}!!! You have to use for ((i=$start;i<=$end;i++)) or for i in eval echo "{$start..$end}"
but eval is not safe.
*** what are the wildcards
 * everything
? single character
[set] any of a number of single character
{} arbitrary strings together in a set
ls my_{finger, toe}s

*** spaces in function argument:
func arg1 arg2 arg3 : 3 string arguments
func "arg1 arg2 arg3" : 1 string arguments
args="arg1 arg2 arg3"; func $args : 3 arguments

*** redirection
redirect error using 2>
kill -HUP 1234 >killout.txt 2>killerr.txt
redirect combined output using >&
kill -1 1234 >killouterr.txt 2>&1
discard output using /dev/null
kill -1 1234 >/dev/null 2>&1
if expr $aaa : "-f" >/dev/null; then echo 'fasdf'; fi

**** bash special variables
$*  a list of all the parameters in a single variable separated by the first character in IFS. if IFS is modified the way $* separates the command into parameters will change.
$@ a variation of $*, does not use IFS to separate parameters
$0 the name of the shell script
$$ the process ID of the shell script
$# the number of parameters passed
PS1,PS2,PS3... how the prompt is displayed
$IFS input field separator

*** string manipulation
${#string}
expr length $string
expr "$string" : '.*'
the length of matched regular expression

*** to extract pattern from string
[[ $1 =~ (Apprentice|Master)?' '?(.*)' ('Level' '[0-9]+')' ]] && echo ${BASH_REMATCH[${#BASH_REMATCH[@]}-1]}
In addition to doing simple matching, bash regular expressions support sub-patterns surrounded by parenthesis for capturing parts of the match. The matches are assigned to an array variable BASH_REMATCH. The entire match is assigned to BASH_REMATCH[0], the first sub-pattern is assigned to BASH_REMATCH[1], etc..
$ AAA=RAxML_log.optimize.RUN.19
$ [[ $AAA =~ RUN.([0-9]+) ]] && echo ${BASH_REMATCH[0]}
RUN.19 
$ [[ $AAA =~ RUN.([0-9]+) ]] && echo ${BASH_REMATCH[1]}
19 

match regular expression with expr
(this is not a good way to match regex in bash, the behavior is weird, use =~)
expr match "$string" '$substring'
expr "$string" : '$substring'
expr match "$string" '.*\([0-9][.][0-9]\)'
$ AAA=RAxML_log.optimize.RUN.19
echo `expr match "$AAA" '.*\.\([0-9]\+\)'`
19

**** index
expr index $string $substring
Numerical position in $string of first character in $substring that matches.

**** to extract substring
${string:position}
${string:position:length}
expr substr $string $position $length
match from beginning
expr match "$string" '\($substring\)'
expr "$string" : '\($substring\)'
match from end
expr match "$string" '.*\($substring\)'
expr "$string" : '.*\($substring\)'

**** string concatenation
#+BEGIN_SRC sh
$string=$string" and else";
# or
$string="$string and else";
#+END_SRC

bash also supports += operator
#+BEGIN_SRC sh
$ A="X Y"
$ A+="Z"
$ echo $A
X YZ
#+END_SRC

*** bash array
The Ultimate Bash Array Tutorial with 15 Examples
http://www.thegeekstuff.com/2010/06/bash-array-tutorial/

declare a bash array
declare -a arrayname=(element1 element2 element3)
declare -a Unix=('Debian' 'Red hat' 'Red hat' 'Suse' 'Fedora');

length of a bash array
${#arrayname[@]}

Print the entire bash array
echo ${arrayname[@]}
or
echo ${arrayname[*]}

+= usage
aa=(hello world)
aa+=(b c d)
# now aa is (hello world b c d)

extract index
${arrayname[1]}

aa=([hello]=world)
aa+=([b]=c)
# aa now contains 2 items

aa="hello"
aa+=" world"
# aa is now "hello world"

*** associative array
aka dictionary in Python and hash in Perl):
declare -A aa
aa[hello]=world
aa[ab]=cd
${a[ab]} # access the value cd
aa=([hello]=world [ab]=cd) # set the associative array in one run
if [[ ${aa[hello]} == world ]]; then
echo equal
fi
print out all the keys in b
for k in "${!b[@]}"doecho"$k"done

declare Integer
declare -i varname
readonly
declare -r varname
array
declare -a varname
associative array
declare -A varname
typeset is a synonym of declare
typeset -i i END

*** expr
The expr builtin can be used as a simple integer calculator. Results are rounded to the nearest integer and floating point is unknown. Be sure to escape the multiplication asterisks (*) to avoid Bash expansion.
numeric comparison
bash$ expr 1 + 1
2
bash$ expr 3 \* 2
6
bash$ expr 6 / 3
2
bash$ expr 6 % 3
0
bash$ expr 3 / 2
1
bash$ expr 3 / 6
0
bash$ expr 6 \* 3.5
expr: non-numeric argument
expr 1 = 1
This is a judgement. It returns 1 (true).

bootsno=$(expr $bootsno + 1);

string comparison
aaa="-f";
if expr $aaa : "-f";  then echo 'fasdf'; fi

*** test: [] and [[]]
test the result 
#+begin_example
[ ... ]
#+end_example

extended test :
#+begin_example
[[ ... ]] 
#+end_example
[[ is equivalent to [ except that [[]] can have &&, ||,< and > work within [[]] test, despite giving an error within a [] construct. And arithmetic evaluation of octal/hexadecimal constants takes place automatically within a [[]] construct


one can do “and” and “or” such as
#+begin_example
[[ -d “$HOME” && -w “$HOME” ]]
#+end_example

*** how to test the exit status of a program

#+begin_src sh
  tail -1 myfile | grep -q PARTIAL
  # Note that you cannot test directly $? (e.g., "if $?; ") because bash will treat $? itself as a command and test its success (in this case always sucess)
  if [ $? -eq 0 ]; then
    echo success
  else
    echo fail
  fi
    
#+end_src
*** test whether a variable is (not) empty
-n string is not null
#+BEGIN_SRC bash
[[ -n "$string" ]] && echo $string
#+END_SRC
-z string is null or empty

*** test a file has non-zero size
#+BEGIN_SRC bash
if [[ -s "$file" ]]
#+END_SRC

*** test string equal
= (or ==) strings are equal
!= strings are not equal

*** arithmetic comparison
-eq equal
-ne not equal
-gt greater than
-ge greater than or equal to
-lt less than
-le less than or equal to

*** echo
**** how to suppress newline in echo
     echo -n取消换行
**** how to print \t in echo
     echo -e "word/tword"
** Python
*** information entropy
#+BEGIN_SRC python
  def entropy(labels):
      """ Computes entropy of label distribution. """
      n_labels = float(len(labels))
  
      if n_labels <= 1:
          return 0
  
      counter = collections.Counter(labels)
      probs = [ _ / n_labels for _ in counter.values()]
      n_classes = np.count_nonzero(probs)
  
      if n_classes <= 1:
          return 0
  
      ent = 0.
  
      # Compute standard entropy.
      for i in probs:
          ent -= i * math.log(i, n_classes)
  
      return ent
  
#+END_SRC
*** how to time a one-liner code snippet?
#+BEGIN_SRC python
python -m timeit "i=5" "i *= i"
#+END_SRC
*** how to get logic AND for all elements in a list
all(list)
any(list) for OR logic
*** matplotlib ggplot style
#+BEGIN_SRC 

from mpltools import style
from mpltools import layout

style.use('ggplot')

figsize = layout.figaspect(scale=1.2)
fig, axes = plt.subplots(ncols=2, nrows=2, figsize=figsize)
ax1, ax2, ax3, ax4 = axes.ravel()

# scatter plot (Note: `plt.scatter` doesn't use default colors)
x, y = np.random.normal(size=(2, 200))
ax1.plot(x, y, 'o')

# sinusoidal lines with colors from default color cycle
L = 2*np.pi
x = np.linspace(0, L)
ncolors = len(plt.rcParams['axes.color_cycle'])
shift = np.linspace(0, L, ncolors, endpoint=False)
for s in shift:
    ax2.plot(x, np.sin(x + s), '-')
ax2.margins(0)

# bar graphs
x = np.arange(5)
y1, y2 = np.random.randint(1, 25, size=(2, 5))
width = 0.25
ax3.bar(x, y1, width)
ax3.bar(x+width, y2, width, color=plt.rcParams['axes.color_cycle'][2])
ax3.set_xticks(x+width)
ax3.set_xticklabels(['a', 'b', 'c', 'd', 'e'])

# circles with colors from default color cycle
for i, color in enumerate(plt.rcParams['axes.color_cycle']):
    xy = np.random.normal(size=2)
    ax4.add_patch(plt.Circle(xy, radius=0.3, color=color))
ax4.axis('equal')
ax4.margins(0)

# Remove ticks on top and right sides of plot
for ax in axes.ravel():
    layout.cross_spines(ax=ax)

plt.show()
#+END_SRC

*** how to get a variable / object by its name as a string?
there are two ways.
1. globals()['var']
2. eval('var') # this is not very safe.
**** spearman r
      from scipy.stats import spearmanr
      rho, p = spearmanr(x, y)
      print rho, p

*** customize matplotlibrc file
cp /etc/matplotlibrc ~/.matplotlib/
then edit .matplotlib/matplotlibrc

*** semantics
**** how to write python main?
#+begin_src python
  def main():
      pass
  # main code goes here
  if __name__ == '__main__':
      main()
#+end_src

***** 更加fancy的写法

#+begin_src python
  import sys
  
  def main(*args):
      try:
        # some code there
        pass
    except:
        # handle some exceptions
        pass
    else:
        return 0 # exit errorlessly
  
  if __name__ == '__main__':
      sys.exit(main(*sys.argv))
#+end_src

**** how to avoid cyclic import
Imports are pretty straightforward really. Just remember the following:

'import' and 'from xxx import yyy' are executable statements. They execute when the running program reaches that line.

If a module is not in sys.modules, then an import creates the new module entry in sys.modules and then executes the code in the module. It does not return control to the calling module until the execution has completed.

If a module does exist in sys.modules then an import simply returns that module whether or not it has completed executing. That is the reason why cyclic imports may return modules which appear to be partly empty.

Finally, the executing script runs in a module named __main__, importing the script under its own name will create a new module unrelated to __main__.

Take that lot together and you shouldn't get any surprises when importing modules.
***** difference between 'import' and 'from xxx import yyy'
      from xxx import yyy need the entire script of xxx be compiled(or executed) before import yyy.
**** how to writing an extension
     The following discuss the reference counting:
     http://bytes.com/topic/python/answers/158440-py_decref-question

**** how to sort a list based on the order of another list?
I have a list of strings like this:

X = ["a", "b", "c", "d", "e", "f", "g", "h", "i"]
Y = [ 0,   1,   1,    0,   1,   2,   2,   0,   1]

What is the shortest way of sorting X using values from Y to get the following output?

    ["a", "d", "h", "b", "c", "e", "i", "f", "g"]

The order for the elements having the same "key" does not matter. I can resort to using for constructs but I am curious if there is a shorter way. Any suggestions?

[x for (y,x) in sorted(zip(y,x))]

This is due to python's behavior of sorting list of tuples.
It automatically sorts a list of tuples by the first elements in the tuples, then by the second elements and so on tuple([1,2,3]) will go before tuple([1,2,4]). If you want to override this behaviour pass a callable as the second argument to the sort method. This callable should return 1, -1, 0.

**** elementwise operation of two lists
[x+y for x,y in zip(list1, list2)]
**** how to count occurrence (estimate frequency) of each item in the list?
***** method 1 (best)
use collections.Counter
import collections
a = [1,1,1,1,2,2,2,2,3,3,4,5,5]
counter=collections.Counter(a)
print(counter)
# Counter({1: 4, 2: 4, 3: 2, 5: 2, 4: 1})
print(counter.values())
# [4, 4, 2, 1, 2]
print(counter.keys())
# [1, 2, 3, 4, 5]
print(counter.most_common(3))
# [(1, 4), (2, 4), (3, 2)]
***** method 2
use itertools.groupby
a = [1,1,1,1,2,2,2,2,3,3,4,5,5]
from itertools import groupby
[len(list(group)) for key, group in groupby(a)]

Output:

[4, 4, 2, 1, 2]
***** method 3
use defaultdict

from collections import defaultdict

words = "apple banana apple strawberry banana lemon"

d = defaultdict(int)
for word in words.split():
    d[word] += 1

This runs in O(n).

**** dot product
use operator.mul
sum(map( operator.mul, vector1, vector2))
there should be better methods
**** how to sort dictionary according to value
***** solution 1
import operator
x = {1:2, 3:4, 4:3, 2:1, 0:0}
sorted_x = sorted(x.items(), key=operator.itemgetter(1))
***** solution 2
from operator import itemgetter
sorted(d.items(), key=itemgetter(1))
***** solution 3
sorted([(value,key) for (key, value) in mydict.items()])
***** solution 4
sorted(dictionaryObject.items(), key=lambda x:x[1])** 字符编码声明
  # -*- coding: utf-8 -*- 

**** get docstring of an object via __doc__ 
>>>print object.__doc__
**** environment variables related to the python interpreter
#!/usr/bin/python
Or
#!/usr/bin/env python
Or
$ set PYTHONINSPECT = 1
$ export PYTHONINSPECT
$ python sample.py
Or
env PYTHONINSPECT = 1 sample.py
**** command line options of python interpreter
D       PYTHONDEBUG     generate debug information
-I      PYTHONINSPECT   Cause the interpreter to go into interactive mode after executing the script
-O      PYTHONOPTIMIZE  optimize the bytecode
-OO     optimize and also remove the document string
-S      give warning when using tab as indentation
-u      PYTHONUNBEFFERED        Force the standard output and error filehandle to operate unbuffered.
-v      PYTHONVERBOSE   generate information about modules imported.
-x      skip the first line
-X      disable class-based exceptions
-c cmd  cmd is used as the script source instead of a source file
-       read the source file from standard input.
**** how to do type coerce
>>>print 5/12
0
>>>print 5.0/12
0.41666666667
int()
float()
coerce(a,b)     coerce the type of a into the type of b
**** numbers:
integer = -1234         32 bits long
decimal = 255
hexadeimal = 0xff       0x is prefix
octal = 0377            0(zero) is prefix
long = 1234L            L is suffix, arbitrary long
float = 1234.5678
scientific = -12.34E-56
complex = 1.2+3.4j      j or J is suffix

*** when to use, "open" vs "file"?
always use "open"
http://stackoverflow.com/questions/112970/python-when-to-use-file-vs-open

*** how to zip?
zip([1,2,3],[4,5,6],[7,8,9]) = [1,4,7], [2,5,8], [3,6,9]
*** string
s.split()  with no argument, it splits on whitespace.
s.ljust(n)  pad the string on the right until n characters if string longer than n, leave the string untruncated.
*** collections
**** collections.defaultdict
     The whole point of the defaultdict is that it will automatically initialize values to zero.
     http://stackoverflow.com/questions/893417/item-frequency-count-in-python
**** collections.Counter - tabulate the frequency
     http://stackoverflow.com/questions/893417/item-frequency-count-in-python
*** numpy
**** numpy.take
x = [1,2,3,4]
numpy.take(x, [1,3])		# return [2,4]
*** scipy
**** cluster
***** hierarchy
****** pdist
       takes m by n ndarray
       regard the array as m data points each of dimension n
       compute m by m distance matrix
       the matrix is in a condensed form.
       has shape: (m(m-1)/2, )
       not (m,m)
       but can be converted to (m,m) by using squareform() function
****** squareform
****** linkage
       compute the dendrogram connectivity from the distance matrix
****** dendrogram
**** k-mean clustering
#+BEGIN_SRC python
from pylab import plot,show
from numpy import vstack,array
from numpy.random import rand
from scipy.cluster.vq import kmeans,vq

# data generation
data = vstack((rand(150,2) + array([.5,.5]),rand(150,2)))

# computing K-Means with K = 2 (2 clusters)
centroids,_ = kmeans(data,2)
# assign each sample to a cluster
idx,_ = vq(data,centroids)

# some plotting using numpy's logical indexing
plot(data[idx==0,0],data[idx==0,1],'ob',
     data[idx==1,0],data[idx==1,1],'or')
plot(centroids[:,0],centroids[:,1],'sg',markersize=8)
show()
#+END_SRC

split into 3 clusters
#+BEGIN_SRC python
# now with K = 3 (3 clusters)
centroids,_ = kmeans(data,3)
idx,_ = vq(data,centroids)

plot(data[idx==0,0],data[idx==0,1],'ob',
     data[idx==1,0],data[idx==1,1],'or',
     data[idx==2,0],data[idx==2,1],'og') # third cluster points
plot(centroids[:,0],centroids[:,1],'sm',markersize=8)
show()
#+END_SRC

*** shlex
**** split

*** random
**** sample
**** shuffle
*** os
**** path
     tutorial <http://www.doughellmann.com/PyMOTW/ospath/>
     getcwd
     expanduser('~/Dropbox/')
     join
     commprefix
     dirname
     split
     splitext
     basename
     expandvars('/path/to/$MYVAR')
     normpath
     abspath
**** listdir
**** sep
**** extsep
**** pardir
**** curdir
**** mkdir
*** sys
**** how to pass command line argument
import sys      # this is required.
filename        sys.argv[0]
the 1st argument   sys.argv[1]
*** itertools
**** itertools.groupby
     http://stackoverflow.com/questions/893417/item-frequency-count-in-python
**** combinations
*** datetime
**** to time python code
from datetime import datetime
time1 = datetime.now()
time2 = datetime.now()
dt = time2 - time1		# a timedelta object
str(dt)			# the human readable format
   
*** rpy
    from rpy import r
    print r.summary(some_vector)
*** matplotlib
**** bar
     plt.bar(left_ends_of_each_bar, heights_of_each_bar)
     plt.xticks([_+bar_width for _ in left_ends_of_each_bar], bar_labels)
**** Set xticks and xticklabels
ax=plt.gca()
ax.set_xticks([<a list of numbers>])
ax.set_xticklabels([<a list of labels>])
**** set the color of boxplot
#+begin_src python
    def setcolor(ob, col):
        for item in ['medians', 'fliers', 'whiskers', 'boxes', 'caps']:
            plt.setp(ob[item], color=col)

        return

    b1=plt.boxplot([[vaf[0] for vaf in vaf_seq] for vaf_seq in vaf_seqs], 
                   positions=[_-0.25 for _ in xrange(1, len(seq_depth_seq)+1)], widths=0.2)
    setcolor(b1, "magenta")
#+end_src

**** imshow and pcolor
*** statistics
**** linear regression
      from scipy import polyfit, polyval
      (ar, br) = polyfit(x, y, 1)
      xr=polyval([ar,br], x)
      print ar, br

*** ete2
**** Tree rendering
t=Tree(..)
ts=TreeStyle()
ts.layout_fn=mylayout
ts.show_leaf_name=False
t.render(“outputfile.png”, tree_style=ts)

**** Layout function
def mylayout(node):
	faces.add_face_to_node(faces.AttrFace(“lcamapped”, fsize=7, fgcolor=”red”), node, column=0, position=”branch-top”)

**** NodeStyle
nstyle=NodeStyle()
nstyle['shape']='sphere'
for n in t.traverse():
n.set_style(nstyle)
*** thread and threading
[2013-07-21 Sun]
Python 标准库提供了 thread 和 threading 两个模块来对多线程进行支持。其中， thread 模块以低级、原始的方式来处理和控制线程，而 threading 模块通过对 thread 进行二次封装，提供了更方便的 api 来处理线程。 虽然使用 thread 没有 threading 来的方便，但它更灵活。今天先介绍 thread 模块的基本使用，
**** thread
#+begin_src python
  #coding=gbk  
  import thread, time, random  
  count = 0  
  def threadTest():  
      global count  
      for i in xrange(10000):  
          count += 1  
  for i in range(10):  
      thread.start_new_thread(threadTest, ()) #如果对start_new_thread函数不是很了解，不要着急，马上就会讲解  
  time.sleep(3)  
  print count #count是多少呢？是10000 * 10 吗？ 
#+end_src
**** threading
Thread 是threading模块中最重要的类之一，可以使用它来创建线程。有两种方式来创建线程：一种是通过继承Thread类，重写它的run方法；另一种是创建一个threading.Thread对象，在它的初始化函数（__init__）中将可调用对象作为参数传入。下面分别举例说明。先来看看通过继承threading.Thread类来创建线程的例子：
#+begin_src python
  #coding=gbk  
  import threading, time, random  
  count = 0  
  class Counter(threading.Thread):  
      def __init__(self, lock, threadName):  
          '''''@summary: 初始化对象。 
           
          @param lock: 琐对象。 
          @param threadName: 线程名称。 
          '''  
          super(Counter, self).__init__(name = threadName)  #注意：一定要显式的调用父类的初始  
  化函数。  
          self.lock = lock  
        
      def run(self):  
          '''''@summary: 重写父类run方法，在线程启动后执行该方法内的代码。 
          '''  
          global count  
          self.lock.acquire()  
          for i in xrange(10000):  
              count = count + 1  
          self.lock.release()
  
  lock = threading.Lock()  
  for i in range(5):   
      Counter(lock, "thread-" + str(i)).start()  
  time.sleep(2)   #确保线程都执行完毕  
  print count
#+end_src
在代码中，我们创建了一个Counter类，它继承了threading.Thread。初始化函数接收两个参数，一个是琐对象，另一个是线程的名称。在Counter中，重写了从父类继承的run方法，run方法将一个全局变量逐一的增加10000。在接下来的代码中，创建了五个Counter对象，分别调用其start方法。最后打印结果。这里要说明一下run方法 和start方法: 它们都是从Thread继承而来的，run()方法将在线程开启后执行，可以把相关的逻辑写到run方法中（通常把run方法称为活动[Activity]。）；start()方法用于启动线程。

**** what's 线程安全?
如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。

或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。

比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成：1. 在 Items[Size] 的位置存放此元素；2. 增大 Size 的值。
在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；
而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。
那好，我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。
**** what cause 线程安全问题
线程安全问题都是由全局变量及静态变量引起的。
  
若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。
**** Python：使用threading模块实现多线程编程一[综述]
Python这门解释性语言也有专门的线程模型，Python虚拟机使用GIL（Global Interpreter Lock，全局解释器锁）来互斥线程对共享资源的访问，但暂时无法利用多处理器的优势。

在Python中我们主要是通过thread和threading这两个模块来实现的，其中Python的threading模块是对thread做了一些包装的，可以更加方便的被使用，所以我们使用 threading模块实现多线程编程。这篇文章我们主要来看看Python对多线程编程的支持。

在语言层面，Python对多线程提供了很好的支持，可以方便地支持创建线程、互斥锁、信号量、同步等特性。下面就是官网上介绍threading模块的基本资料及功能：

*实现模块*
thread：多线程的底层支持模块，一般不建议使用；
threading：对thread进行了封装，将一些线程的操作对象化。

*threading模块*
Thread 线程类，这是我们用的最多的一个类，你可以指定线程函数执行或者继承自它都可以实现子线程功能；
Timer与Thread类似，但要等待一段时间后才开始运行；
Lock 锁原语，这个我们可以对全局变量互斥时使用；
RLock 可重入锁，使单线程可以再次获得已经获得的锁；
Condition 条件变量，能让一个线程停下来，等待其他线程满足某个“条件”；
Event 通用的条件变量。多个线程可以等待某个事件发生，在事件发生后，所有的线程都被激活；
Semaphore为等待锁的线程提供一个类似“等候室”的结构；
BoundedSemaphore 与semaphore类似，但不允许超过初始值；
Queue：实现了多生产者（Producer）、多消费者（Consumer）的队列，支持锁原语，能够在多个线程之间提供很好的同步支持。

*其中Thread类*
是你主要的线程类，可以创建进程实例。该类提供的函数包括：
getName(self) 返回线程的名字
isAlive(self) 布尔标志，表示这个线程是否还在运行中
isDaemon(self) 返回线程的daemon标志
join(self, timeout=None) 程序挂起，直到线程结束，如果给出timeout，则最多阻塞timeout秒
run(self) 定义线程的功能函数
setDaemon(self, daemonic) 把线程的daemon标志设为daemonic
setName(self, name) 设置线程的名字
start(self) 开始线程执行

*其中Queue提供的类*
Queue队列
LifoQueue后入先出（LIFO）队列
PriorityQueue 优先队列

接下来的一系列文章，我们将会用一个一个示例来展示threading的各个功能，包括但不限于：两种方式起线程、threading.Thread类的重要函数、使用Lock互斥及RLock实现重入锁、使用Condition实现生产者和消费者模型、使用Event和Semaphore多线程通信。

**** Python：使用threading模块实现多线程编程二[两种方式起线程]
在Python中我们主要是通过thread和threading这两个模块来实现的，其中Python的threading模块是对thread做了一些包装的，可以更加方便的被使用，所以我们使用threading模块实现多线程编程。一般来说，使用线程有两种模式，一种是创建线程要执行的函数，把这个函数传递进Thread对象里，让它来执行；另一种是直接从Thread继承，创建一个新的class，把线程执行的代码放到这个新的 class里。
***** 将函数传递进Thread对象
#+begin_src python
  '''''  
  Created on 2012-9-5  
     
  @author:  walfred 
  @module: thread.ThreadTest1  
  @description: 
  '''    
  import threading  
    
  def thread_fun(num):  
      for n in range(0, int(num)):  
          print " I come from %s, num: %s" %( threading.currentThread().getName(), n)  
    
  def main(thread_num):  
      thread_list = list();  
      # 先创建线程对象  
      for i in range(0, thread_num):  
          thread_name = "thread_%s" %i  
          thread_list.append(threading.Thread(target = thread_fun, name = thread_name, args = (20,)))  
        
      # 启动所有线程     
      for thread in thread_list:  
          thread.start()  
        
      # 主线程中等待所有子线程退出  
      for thread in thread_list:  
          thread.join()  
    
  if __name__ == "__main__":  
      main(3)  
#+end_src
程序启动了3个线程，并且打印了每一个线程的线程名字，这个比较简单吧，处理重复任务就派出用场了，下面介绍使用继承threading的方式；

***** 继承自threading.Thread类
#+begin_src python
    ''''' 
    Created on 2012-9-6 
      
    @author: walfred 
    @module: thread.ThreadTest2 
    '''  
      
    import threading  
      
    class MyThread(threading.Thread):  
        def __init__(self):  
            threading.Thread.__init__(self);  
              
        def run(self):  
            print "I am %s" %self.name  
              
    if __name__ == "__main__":  
        for thread in range(0, 5):  
            t = MyThread()  
            t.start()  
#+end_src
接下来的文章，将会介绍如何控制这些线程，包括子线程的退出，子线程是否存活及将子线程设置为守护线程(Daemon)。
**** Python：使用threading模块实现多线程编程三[threading.Thread类的重要函数]
这篇文章主要介绍threading模块中的主类Thread的一些主要方法，实例代码如下：

#+begin_src python
'''''  
Created on 2012-9-7  
   
@author:  walfred 
@module: thread.ThreadTest3  
@description: 
'''    
import threading  
  
class MyThread(threading.Thread):  
    def __init__(self):  
        threading.Thread.__init__(self)  
      
    def run(self):  
        print "I am %s" % (self.name)  
      
if __name__ == "__main__":  
    for i in range(0, 5):  
        my_thread = MyThread()  
        my_thread.start()
#+end_src

1 name相关
你可以为每一个thread指定name，默认的是Thread-No形式的，如上述实例代码打印出的一样：
---
I am Thread-1
I am Thread-2
I am Thread-3
I am Thread-4
I am Thread-5
---
当然你可以指定每一个thread的name，这个通过setName方法，代码：

#+begin_src python
  def __init__(self):  
      threading.Thread.__init__(self)  
      self.setName("new" + self.name)  
#+end_src

2 join方法
join方法原型如下，这个方法是用来阻塞当前上下文，直至该线程运行结束：

#+begin_src python
  def join(self, timeout=None):  
#+end_src

3 setDaemon方法
当我们在程序运行中，执行一个主线程，如果主线程又创建一个子线程，主线程和子线程就分兵两路，当主线程完成想退出时，会检验子线程是否完成。如果子线程未完成，则主线程会等待子线程完成后再退出。但是有时候我们需要的是，只要主线程完成了，不管子线程是否完成，都要和主线程一起退出，这时就可以用setDaemon方法，并设置其参数为True。

**** Python：使用threading模块实现多线程编程四[使用Lock互斥锁]
前面已经演示了Python：使用threading模块实现多线程编程二两种方式起线程和Python：使用threading模块实现多线程编程三threading.Thread类的重要函数，这两篇文章的示例都是演示了互不相干的独立线程，现在我们考虑这样一个问题：假设各个线程需要访问同一公共资源，我们的代码该怎么写？

#+begin_src python
''''' 
Created on 2012-9-8 
  
@author: walfred 
@module: thread.ThreadTest3 
'''  
import threading  
import time  
   
counter = 0  
   
class MyThread(threading.Thread):  
    def __init__(self):  
        threading.Thread.__init__(self)  
      
    def run(self):  
        global counter  
        time.sleep(1);  
        counter += 1  
        print "I am %s, set counter:%s" % (self.name, counter)  
      
if __name__ == "__main__":  
    for i in range(0, 200):  
        my_thread = MyThread()  
        my_thread.start()
#+end_src
解决上面的问题，我们兴许会写出这样的代码，我们假设跑200个线程，但是这200个线程都会去访问counter这个公共资源，并对该资源进行处理(counter += 1)，代码看起来就是这个样了，但是我们看下运行结果：
---
I am Thread-69, set counter:64
I am Thread-73, set counter:66I am Thread-74, set counter:67I am Thread-75, set counter:68I am Thread-76, set counter:69I am Thread-78, set counter:70I am Thread-77, set counter:71I am Thread-58, set counter:72I am Thread-60, set counter:73I am Thread-62, set counter:74I am Thread-66, set counter:75I am Thread-70, set counter:76I am Thread-72, set counter:77I am Thread-79, set counter:78I am Thread-71, set counter:78
---
打印结果我只贴了一部分，从中我们已经看出了这个全局资源(counter)被抢占的情况，问题产生的原因就是没有控制多个线程对同一资源的访问，对数据造成破坏，使得线程运行的结果不可预期。这种现象称为“线程不安全”。在开发过程中我们必须要避免这种情况，那怎么避免？这就用到了我们在综述中提到的互斥锁了。

*互斥锁概念*
Python编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为" 互斥锁" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。在Python中我们使用threading模块提供的Lock类。

我们对上面的程序进行整改，为此我们需要添加一个互斥锁变量mutex = threading.Lock()，然后在争夺资源的时候之前我们会先抢占这把锁mutex.acquire()，对资源使用完成之后我们在释放这把锁mutex.release()。代码如下：

#+begin_src python
  ''''' 
  Created on 2012-9-8 
    
  @author: walfred 
  @module: thread.ThreadTest4 
  '''  
    
  import threading  
  import time  
     
  counter = 0  
  mutex = threading.Lock()  
     
  class MyThread(threading.Thread):  
      def __init__(self):  
          threading.Thread.__init__(self)  
        
      def run(self):  
          global counter, mutex  
          time.sleep(1);  
          if mutex.acquire():  
              counter += 1  
              print "I am %s, set counter:%s" % (self.name, counter)  
              mutex.release()  
        
  if __name__ == "__main__":  
      for i in range(0, 100):  
          my_thread = MyThread()  
          my_thread.start()
#+end_src

*同步阻塞*
当一个线程调用Lock对象的acquire()方法获得锁时，这把锁就进入“locked”状态。因为每次只有一个线程1可以获得锁，所以如果此时另一个线程2试图获得这个锁，该线程2就会变为“blo同步阻塞状态。直到拥有锁的线程1调用锁的release()方法释放锁之后，该锁进入“unlocked”状态。线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。

*进一步考虑*
通过对公共资源使用互斥锁，这样就简单的到达了我们的目的，但是如果我们又遇到下面的情况：
1、遇到锁嵌套的情况该怎么办，这个嵌套是指当我一个线程在获取临界资源时，又需要再次获取；
2、如果有多个公共资源，在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源；

上述这两种情况会直接造成程序挂起，即死锁，下面我们会谈死锁及可重入锁RLock。

**** Python：使用threading模块实现多线程编程五[死锁的形成]
前一篇文章Python：使用threading模块实现多线程编程四[使用Lock互斥锁]我们已经开始涉及到如何使用互斥锁来保护我们的公共资源了，现在考虑下面的情况
如果有多个公共资源，在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，这会引起什么问题？
*死锁概念*
所谓死锁： 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。
#+begin_src python
  ''''' 
  Created on 2012-9-8 
    
  @author: walfred 
  @module: thread.TreadTest5 
  '''   
  import threading  
     
  counterA = 0  
  counterB = 0  
     
  mutexA = threading.Lock()  
  mutexB = threading.Lock()  
     
  class MyThread(threading.Thread):  
      def __init__(self):  
          threading.Thread.__init__(self)  
        
      def run(self):  
          self.fun1()  
          self.fun2()  
            
      def fun1(self):  
          global mutexA, mutexB  
          if mutexA.acquire():  
              print "I am %s , get res: %s" %(self.name, "ResA")  
                
              if mutexB.acquire():  
                  print "I am %s , get res: %s" %(self.name, "ResB")  
                  mutexB.release()  
               
          mutexA.release()   
            
      def fun2(self):  
          global mutexA, mutexB  
          if mutexB.acquire():  
              print "I am %s , get res: %s" %(self.name, "ResB")  
                
              if mutexA.acquire():  
                  print "I am %s , get res: %s" %(self.name, "ResA")  
                  mutexA.release()  
               
          mutexB.release()   
        
  if __name__ == "__main__":  
      for i in range(0, 100):  
          my_thread = MyThread()  
          my_thread.start()
#+end_src

代码中展示了一个线程的两个功能函数分别在获取了一个竞争资源之后再次获取另外的竞争资源，我们看运行结果：
---
I am Thread-1 , get res: ResA
I am Thread-1 , get res: ResB
I am Thread-2 , get res: ResAI am Thread-1 , get res: ResB
---
可以看到，程序已经挂起在那儿了，这种现象我们就称之为”死锁“。

*避免死锁*
避免死锁主要方法就是：正确有序的分配资源，避免死锁算法中最有代表性的算法是Dijkstra E.W 于1968年提出的银行家算法。
**** Python：使用threading模块实现多线程编程六[可重入锁RLock]
考虑这种情况：如果一个线程遇到锁嵌套的情况该怎么办，这个嵌套是指当我一个线程在获取临界资源时，又需要再次获取。
根据这种情况，代码如下：

#+begin_src python
  ''''' 
  Created on 2012-9-8 
    
  @author: walfred 
  @module: thread.ThreadTest6 
  '''  
    
  import threading  
  import time  
     
  counter = 0  
  mutex = threading.Lock()  
     
  class MyThread(threading.Thread):  
      def __init__(self):  
          threading.Thread.__init__(self)  
        
      def run(self):  
          global counter, mutex  
          time.sleep(1);  
          if mutex.acquire():  
              counter += 1  
              print "I am %s, set counter:%s" % (self.name, counter)  
              if mutex.acquire():  
                  counter += 1  
                  print "I am %s, set counter:%s" % (self.name, counter)  
                  mutex.release()  
              mutex.release()  
        
  if __name__ == "__main__":  
      for i in range(0, 200):  
          my_thread = MyThread()  
          my_thread.start() 
#+end_src

这种情况的代码运行情况如下：
之后就直接挂起了，这种情况形成了最简单的死锁。

那有没有一种情况可以在某一个线程使用互斥锁访问某一个竞争资源时，可以再次获取呢？在Python中为了支持在同一线程中多次请求同一资源，python提供了“可重入锁”：threading.RLock。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁：

代码只需将上述的：
=mutex = threading.Lock()=
替换成：
=mutex = threading.RLock()=

**** Python：使用threading模块实现多线程编程七[使用Condition实现复杂同步]
目前我们已经会使用Lock去对公共资源进行互斥访问了，也探讨了同一线程可以使用RLock去重入锁，但是尽管如此我们只不过才处理了一些程序中简单的同步现象，我们甚至还不能很合理的去解决使用Lock锁带来的死锁问题。所以我们得学会使用更深层的解决同步问题。

Python提供的Condition对象提供了对复杂线程同步问题的支持。Condition被称为条件变量，除了提供与Lock类似的acquire和release方法外，还提供了wait和notify方法。

使用Condition的主要方式为：线程首先acquire一个条件变量，然后判断一些条件。如果条件不满足则wait；如果条件满足，进行一些处理改变条件后，通过notify方法通知其他线程，其他处于wait状态的线程接到通知后会重新判断条件。不断的重复这一过程，从而解决复杂的同步问题。

下面我们通过很著名的“生产者-消费者”模型来来演示下，在Python中使用Condition实现复杂同步。

#+begin_src python
  ''''' 
  Created on 2012-9-8 
    
  @author: walfred 
  @module: thread.TreadTest7 
  '''  
    
  import threading  
  import time  
     
  condition = threading.Condition()  
  products = 0  
     
  class Producer(threading.Thread):  
      def __init__(self):  
          threading.Thread.__init__(self)  
            
      def run(self):  
          global condition, products  
          while True:  
              if condition.acquire():  
                  if products < 10:  
                      products += 1;  
                      print "Producer(%s):deliver one, now products:%s" %(self.name, products)  
                      condition.notify()
                  else:
                      print "Producer(%s):already 10, stop deliver, now products:%s" %(self.name, products)
                      condition.wait();
                  condition.release()  
                  time.sleep(2)  
            
  class Consumer(threading.Thread):  
      def __init__(self):  
          threading.Thread.__init__(self)  
            
      def run(self):  
          global condition, products  
          while True:  
              if condition.acquire():  
                  if products > 1:  
                      products -= 1  
                      print "Consumer(%s):consume one, now products:%s" %(self.name, products)  
                      condition.notify()  
                  else:  
                      print "Consumer(%s):only 1, stop consume, products:%s" %(self.name, products)  
                      condition.wait();  
                  condition.release()  
                  time.sleep(2)  
                    
  if __name__ == "__main__":  
      for p in range(0, 2):  
          p = Producer()  
          p.start()  
            
      for c in range(0, 10):  
          c = Consumer()  
          c.start()
#+end_src
代码中主要实现了生产者和消费者线程，双方将会围绕products来产生同步问题，首先是2个生成者生产products ，而接下来的10个消费者将会消耗products，代码运行如下：
---
Producer(Thread-1):deliver one, now products:1
Producer(Thread-2):deliver one, now products:2
Consumer(Thread-3):consume one, now products:1
Consumer(Thread-4):only 1, stop consume, products:1
Consumer(Thread-5):only 1, stop consume, products:1
Consumer(Thread-6):only 1, stop consume, products:1
Consumer(Thread-7):only 1, stop consume, products:1
Consumer(Thread-8):only 1, stop consume, products:1
Consumer(Thread-10):only 1, stop consume, products:1
Consumer(Thread-9):only 1, stop consume, products:1
Consumer(Thread-12):only 1, stop consume, products:1
Consumer(Thread-11):only 1, stop consume, products:1
---
另外：Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock；除了notify方法外，Condition对象还提供了notifyAll方法，可以通知waiting池中的所有线程尝试acquire内部锁。由于上述机制，处于waiting状态的线程只能通过notify方法唤醒，所以notifyAll的作用在于防止有线程永远处于沉默状态。

**** Python：使用threading模块实现多线程编程八[使用Event实现线程间通信]
使用threading.Event可以实现线程间相互通信，之前的Python：使用threading模块实现多线程编程七[使用Condition实现复杂同步]我们已经初步实现了线程间通信的基本功能，但是更为通用的一种做法是使用threading.Event对象。
使用threading.Event可以使一个线程等待其他线程的通知，我们把这个Event传递到线程对象中，Event默认内置了一个标志，初始值为False。一旦该线程通过wait()方法进入等待状态，直到另一个线程调用该Event的set()方法将内置标志设置为True时，该Event会通知所有等待状态的线程恢复运行。
#+begin_src python
  ''''' 
  Created on 2012-9-9 
    
  @author: walfred 
  @module: thread.TreadTest8 
  '''  
    
  import threading  
  import time  
    
  class MyThread(threading.Thread):  
      def __init__(self, signal):
          threading.Thread.__init__(self)  
          self.singal = signal  
            
      def run(self):  
          print "I am %s,I will sleep ..."%self.name  
          self.singal.wait()  
          print "I am %s, I awake..." %self.name  
            
  if __name__ == "__main__":  
      singal = threading.Event()  
      for t in range(0, 3):  
          thread = MyThread(singal)  
          thread.start()  
        
      print "main thread sleep 3 seconds... "  
      time.sleep(3)  
        
      singal.set()
#+end_src
运行效果如下：
---
I am Thread-1,I will sleep ...
I am Thread-2,I will sleep ...
I am Thread-3,I will sleep ...
main thread sleep 3 seconds...
I am Thread-1, I awake...
I am Thread-2, I awake...
I am Thread-3, I awake...
---
*** cProfile 
需要安装python-profiler
**** 命令行profile
     python -m cProfile -o ProfileOutput -s 'cumulative' myscript.py
     -m tells Python to run the library module profile as a script
     optional:
     -o tells cProfile to write the profile data to a specific file
     -s what to order by
**** Interactive Shell Profile
     import cProfile
     cProfile.run('foo()','ProfileOutput')
     import pstats
     pstats.Stats('ProfileOutput')
**** pstats (用来查看cProfile生成的文件)
     import pstats
     p = pstats.Stats('profile_file')
     p.sort_stats('cumulative').print_stats(10)  # sort by cumulative time
*** Cython
**** Build manually using gcc
     1. This will create a .c file
     cython mymodule.pyx
     
     2. Compile .c into .o
     gcc -O2 -c -fPIC -I/usr/include/python2.6/ mymodule.c
     -c
     produces a .o file instead of an executable.
     -fPIC
     Produces position independent code, so we can dynamically link against it
     -I/usr/include/python2.6/
     the location of the Python 2.6 include file
     
     3. Link the .o into a .so
     gcc -shared mymodule.o -o mymodule.so
     -shared
     produces a shared-object file, instead of an executable.
     mymodule.o
     is the name of the module you wish to compile.
     -lxosd (optional)
     links against the C-library xosd.
     xosd(X On Screen Display) library displays text on your screen.
     -o mymodule.so
     causes gcc to put the output into a file called mymodule.so
**** compile using distutils
***** save the following as setup.py
      from disutils.core import setup
      from disutils.extension import Extension
      from Pyrex.Distutils import build_ext
      setup(
      name = "PyrexGuide",
      ext_modules=[ 
      Extension("mymodule", ["mymodule.pyx"], libraries = ["xosd"])
      ],
      cmdclass = {'build_ext': build_ext}
      )
***** python setup.py build_ext --inplace
**** Use your module
     import mymodule
     print dir(mymodule)
*** vim_python mode:
    ]t      - jump to beginning of block
    ]e      -- Jump to end of block
    ]v      -- Select (Visual Line Mode) block
    ]<      -- Shift block to left
    ]>      -- Shift block to right
    ]#      -- Comment selection
    ]u      -- Uncomment selection
    ]c      -- Select current/previous class
    ]d      -- Select current/previous function
    ]<up>   -- Jump to previous line with the same/lower indentation
    ]<down> -- Jump to next line with the same/lower indentation
*** xml
**** sax
***** good xml references:
      www.boddie.org.uk/python/XML_intro.html
***** xml.sax explained
      http://mail.python.org/pipermail/python-dev/2000-October/009946.html
      and see Troy's pyGS2 script in Dropbox/scripts/python/analysis
      a general pattern is 
      --
      from xml.sax import make_parser, ContentHandler
      parser = make_parser()
      # build a handler
      parser.setContentHandler(handler)
      parser.parse(fstream)
****** how to define a handler
       class YourHandler(ContentHandler):
       you need to define:
       __init__, 
       startElement(self,name,attrs), endElement(self,name), and characters(self,ch)
*** optparse

*** matplotlib
[plt.ylabel]    plt.ylabel('some numbers')
[plt.show]      plt.show()
[plt.axis]      plt.axis([0,6,0,20])
imshow		takes a matrix and plot it as image
contour		plot the contour
**** configure backend
     edit .matplotlib/matplotlibrc file
     To locate .matplotlib directory
     do
     >>> import matplotlib as mpl
     >>> mpl.get_configdir()
     '/home/wanding/.matplotlib'
     and write in matplotlibrc file
     backend : WXAgg
     Or in most cased
     backend : TkAgg
     
     import matplotlib
     matplotlib.use('PS')
**** change a [(x1, y1), (x2, y2)] into [x1,x2], [y1, y2]
***** zip() and unzip
***** numpy.asarray method
      xy = numpy.asarray([(x1, y1), (x2, y2)]
      xy[:,0], xy[:,1]
**** the structure of matplotlib
***** matplotlib.artist.Artist
      base class for adding something onto the canvas
      the most useful plotting functions are defined there.
****** attribute
******* canvas
       	matplotlib.backends.backend_tkagg.FigureCanvasTkAgg
******* figure
       	matplotlib.figure.Figure
       	set in set_figure() function
******* axes
       	matplotlib.axes.Axes, where the artist "resides".
       	initialized to None
******* _picker
       	can be None, a boolean, a float, or a function
       	see set_picker() docstring for detail
******* zorder
       	any number, artists with lower zorder values are drawn first
******* _alpha
       	the alpha value used for blending
       	float (0.0 transparent through 1.0 opaque)
****** function
******* set_picker()
       	set self._picker which is often overrides by the same name
       	in the derived classes. 
******* update()
       	set the parameters from the **kwargs
       	if we specify "picker = 5" in the argument
       	the update() would call self.set_picker(5)
******* pick()
       	call matplotlib.backend_bases.FigureCanvasBase.pick_event()
******* set_figure()
******* set_zorder()
       	take any number, artists with lower zorder values are drawn first
******* set_alpha()
       	set the alpha value used for blending
       	take a floating number (0.0 transparent through 1.0 opaque)
****** matplotlib.axes.Axes
******* attributes
******** name
       	 rectilinear
******** _get_lines
       	 matplotlib.axes._process._plot_var_args
       	 initialized to matplotlib.axes._process_plot_var_args(self)
       	 when it's called, the matplotlib.axes._process_plot_var_args.__call__()
       	 would be called.
******** lines
       	 a list of matplotlib.lines.line2D
******** patches
******** texts
******** tables
******** artists
******** images
******** collections
******* functions
******** cla()
       	 clear current axes
******** set_title()
       	 return matplotlib.text.Text object       
******** add_artist()
******** add_collection()
******** add_line()
******** add_patch()
******** add_table()
******** pie()
       	 call add_patch(), make a piechart
******* matplotlib.projections.polar.PolarAxes
******* matplotlib.projections.geo.GeoAxes
******** matplotlib.projections.geo.AitoffAxes
******** matplotlib.projections.geo.HammerAxes
******** matplotlib.projections.geo.MollweideAxes
******** matplotlib.projections.geo.LamberAxes
****** matplotlib.figure.Figure
******* attributes
******** canvas
       	 this is originally "None"
       	 and is usually set in matplotlib.pyplot.figure()
       	 into matplotlib.backends.backend_tkagg.FigureCanvasTkAgg
******** axes
       	 a list of matplotlib.axes.Axes
******** _axstack
       	 matplotlib.cbook.Stack
       	 for maintaining the current axes
******* functions
******** add_subplot()
       	 return matplotlib.axes.subplot_class_factory() class object,
       	 Notice that this object is obscure since the class's created on the fly
       	 in most cases it's a joint child class of matplotlib.axes.SubplotBase
       	 and the projection class object
******** sca()
       	 take a matplotlib.axes.Axes as its argument
       	 bubble the current axes in the self._axstack
******** gca()
       	 get current axes
       	 this returns a projection_class directly or calls add_subplot()
       	 and return a joint object of projection_class and SubplotBase
       	 class, if multiple axes exists, the gca() returns the top in
       	 the self._axstack()
******** clf()
       	 delete all the axes and other stuff drawn
       	 now self.axes become []
****** matplotlib.patches.Patch
       geometric shapes of various kinds
******* matplotlib.patches.Shadow
******* matplotlib.patches.Rectangle
******* matplotlib.patches.RegularPolygon
******** matplotlib.patches.CirclePolygon
******* matplotlib.patches.PathPatch
******* matplotlib.patches.Polygon
******** matplotlib.patches.FancyArrow
******* matplotlib.patches.Wedge
******* matplotlib.patches.Arrow
******* matplotlib.patches.YAArrow
******* matplotlib.patches.Ellipse
******** matplotlib.patches.Circle
******** matplotlib.patches.Arc
****** matplotlib.collections.Collection
       jointly inherited from matplotlib.artist.Artist
       and matplotlib.cm.ScalarMappable
******* matplotlib.collections.QuadMesh
******* matplotlib.collections.PollyCollection
******** matplotlib.collections.BrokenBarHCollection
******* matplotlib.collections.RegularPolyCollection
******** matplotlib.collections.StarPolygonCollection
******** matplotlib.collections.AsteriskPolygonCollection
******* matplotlib.collections.LineCollection
******* matplotlib.collections.EllipseCollection
******* matplotlib.collections.PatchCollection
****** matplotlib.lines.line2D
******* funcs
******** set_picker()
       	 set self._picker which is a matplotlib.artist.Artist member
***** matplotlib.artist.ArtistInspector
***** matplotlib.backend_bases.FigureCanvasBase
****** attributes
******* figure
       	matplotlib.figure.Figure
******* callbacks
       	matplotlib.cbooks.CallbackRegistry
       	it is initialized to have the record of all the events
******* events
       	all the possible responsive events
       	this includes, resize_event, draw_event, key_press_event,
       	key_release_event, button_press_event, button_release_event,
       	scroll_event, motion_notify_event,
       	pick_event, idle_event, figure_enter_event, figure_leave_event,
       	anxes_enter_event, axes_leave_event.
****** function
       the xxx_event function would be triggered by the human
       interaction with canvas
******* mpl_connect()
       	connect a string to a function(event) where event is
       	matplotlib.backend_bases.Event
******* pick_event()
       	callbacks.process(s, PickEvent)
******* scroll_event()
       	callbacks.process(s, MouseEvent)
******* button_press_event()
       	callbacks.process(s, MouseEvent)
******* button_release_event()
       	callbacks.process(s, MouseEvent)
******* motion_notify_event()
       	callbacks.process(s, MouseEvent)
****** matplotlib.backends.backend_tkagg.FigureCanvasTkAgg
       needs matplotlib.figure.Figure to initialize
***** matplotlib.backend_bases.FigureManagerBase
****** attributes
******* canvas
       	a matplotlib.backends.backend_tkagg.FigureCanvasTkAgg
****** matplotlib.backends.backend_tkagg.FigureManagerTkAgg
       needs matplotlib.backends.backend_tkagg.FigureCanvasTkAgg to
       initialize
***** matplotlib.backend_bases.Event
      needs a matplotlib.backend_bases.FigureCanvas to initialize
****** attributes
******* canvas
       	FigureCanvas
******* guiEvent
       	the GUI event that triggered the event
****** matplotlib.backend_bases.IdleEvent
****** matplotlib.backend_bases.DrawEvent
****** matplotlib.backend_bases.LocationEvent
******* matplotlib.backend_bases.MouseEvent
******* matplotlib.backend_bases.KeyEvent
****** matplotlib.backend_bases.PickEvent
       needs a MouseEvent and an Artist to initialize
       the pick_event would check how close the coordinates of this
       MouseEvent and this Artist is.
******* mouseevent
       	matplotlib.backend_bases.MouseEvent
******* artist
       	matplotlib.artist.Artist
***** matplotlib.axes._pylab_helpers.Gcf
      Manage a set of integer-numbered figures.
****** attributes
******* _aciveQue
       	a list of active matplotlib.figure.Figure()
******* figs
       	dictionary
****** funcs
******* get_fig_manager()
       	take an interger number *num* as argument
       	return figs[num]
******* get_active
       	return Gcf._activeQue[-1]
***** matplotlib.axes._process_plot_var_args
      needs matplotlib.axes.Axes and command (default to "plot") to
      initiaize
****** attribute
******* axes
******* command
****** funcs
******* __call__
       	this call mainly does set_units
***** matplotlib.patches._Style
***** matplotlib.pyplot (module)
****** funcs
******* figure()
       	return a matplotlib.figure.Figure using either
       	_pylab_helpers.Gcf.get_fig_manager(num) to get a current figure
       	or new_figure_manager (returned by pylab_setup from
       	matplotlib.backends.__init__) to create a new figure.
******* pie()
       	call matplotlib.axes.Axes.pie()
***** matplotlib.backends.backend_tkagg (module)
****** attributes
******* rcParams
       	matplotlib.rcParams
****** functions
******* draw_if_interactive()
******* show()
******* new_figure_manager()
***** matplotlib.backends (package)
****** function
******* pylab_setup()
       	import backends according to the string "backend" which is
       	obtained by matplotlib.get_backend()
       	mainly import
       	1. matplotlib.backends.backend_XXX.new_figure_manager() 
       	2. matplotlib.backends.backend_XXX.draw_if_interactive()
       	3. matplotlib.backends.backend_XXX.show()
****** possible backends can be:
       1. backend_agg
       2. backend_cairo
       3. backend_cocoaagg
       4. backedn_emf
       5. backend_fltkagg
       6. backend_gtk
       7. backend_gtkagg
       8. backend_gtkcairo
       9. backend_macosx
       10. backend_mixed
       11. backend_pdf
       12. backend_qt
       13. backend_ps
       14. backend_qt4
       15. backend_qt4agg
       16. backend_svg
       17. backend_template
       18. backend_tkagg (default)
       19. backend_wx
       20. backend_wxagg
       21. tkagg (not a backend)
***** matplotlib.backend_bases.NavigationToolbar2
***** matplotlib.cbook.CallbackRegistry
****** attributs
******* signals
       	a set of strings (signals)
******* callbacks
       	a dictionary mapping signals to a dictionary mapping calback id
       	to the callback function
****** functions
******* process()
       	call all the functions registered to the signal string.
***** matplotlib.cbook.Stack
***** the relationship between figure.Figure and backends.backend_tkagg.FigureCanvasTkAgg
      they are 1 on 1. figure.Figure has canvas attribute which is
      FigureCanvasTkAgg while FigureCanvasTkAgg has figure attribute
      which is figure.Figure.
      
      When they are initialized in pyplot.figure(), figure.Figure is
      first initialized with canvas set to None. then through
      backend_tkagg.new_figure_manager() function, FigureCanvasTkAgg is
      initialized with the figure.Figure() object. 

      In the initialization of FigureCanvasBase which is the base class
      of FigureCanvasTkAgg, figure.set_canvas is called.
***** Tkinter.Frame
****** matplotlib.backends.backend_tkagg.NavigationToolbar
****** matplotlib.backends.backend_tkagg.NavigationToolbar2TkAgg

**** how to plot hexbin
     plt.hexbin(entropies, error_seqs, bins='log', gridsize=20, cmap=cm.Greys)
**** remove edgecolor in scatterplot
     plt.scatter(entropies, error_seqs, edgecolor='none')
**** adjust margin
plt.subplots_adjust(bottom=0.15)
plt.subplots_adjust(bottom=0.08, top=0.99, left=0.08,right=0.99)
plt.savefig(myfig,bbox_inches='tight',pad_inches=0.05)
**** remove margin
plt.savefig(myfig,bbox_inches='tight',pad_inches=0.05)
**** the callback mechanism used in matplotlib
***** register a function func to a string s
      CallbackRegistry.connect(s, func)
      or in matplotlib: mpl_connect(s, func) (actually this subroutine call the
      CallbackRegistry.connects)
      Note: multiple functions can be connected to s. When s is called, all these functions are called.
***** call all the function registered to s
      CallbackRegistry.process(s, *args, **kwargs)
      call all the functions registered to s with  *args and **kwargs
***** s is so-called signals
*** ipython
**** how to paste code to ipython?
%paste
**** reload problem: e.g. we have module.py then we need to first import module
     import module
     reload(module)
     then use module.class
**** useful magic command
     who, whos 
     psearch msg*
     psearch msg* int
     store msgflag
     store msgflag > /tmp/a.txt
     reset
     store -r        # recover the stored setting
     store -z        # clean the storage
     logstate
     logstart
     logon
     logoff
     lsmagic
     lsmagic??
     lsmagic?
     msgflag?
     p short for "print"
     p sys.path
     page sys.path
     help(sys)
     help('for')
     \function
     help()
     topics
     functions
     pdef re.match		# show function definition
     pdoc re.match		# show the docstring
     pinfo re.match		# show all the information (including
     # definition, docstring, stringform and file location) If you want
     # to check the file location. This is the command to issue. This is
     the same as ?? and ? suffix.
     psource re.match	# print part of the source file that contains the function
     magic
     pfile re.match 		# print out the entire file
     edit -x re.match
     pwd
     cd /tmp
     pushd /usr/lib/
     popd
     dhist
     dirs
     bookmark btree
     bookmark site /usr/lib/python2
     bookmark -l     # list bookmarks
     cd -<n>
     cd?
     ![BashCommand]
     patt = '*.py'
     !ls -l $patt
     !ls -l ${patt+'c'}
     
     alias
     alias pr echo you said %s
     pr Hello
     unalias pr

     def go(patt=patt)
     !ls -l $patt
     go()
     go('*.so')

     len(list)
     list.s  # smart list
     list.x  # newline list
     list.n  # newline string
     !ls *.py | sort

     run calc
     less
     pycat calc
     run -p calc profile
     run -d calc debugger
     q

     _i _ii _iii
     _i1
     In[3]
     hist 1 10
     hist -r # filter all the magic command for cut and paste use
     hist 10
     exec _i3
     exec In[1:4]

     macro
     macro begin 1-4 5
     print macro
     store begin

     edit
     save apple 1-3 5        # save line 1 to 3 and 5 to file apple
     cat apple.py
     pycat apple.py          # with syntax coloring
     edit _i163

     cpaste # end with "--"
     Out[118]
     Out[120]
     less ipython_log.py
     runlog


     Debug:
     xmode Plain
     xmode Verbose
     xmode Context
     pdb
     run -d calc2
     c

     To embed into code:
     from IPython.Shell import IPShellEmbed
     ipshell = IPShellEmbed()
     ipshell()

     time sum(range(100000))
     timeit sum(range(1000))
     time zopedocs();        # ; inhibit output
     prun    # profile run expression on file
     run -p  # file on expression
     less gofetch.py
     ed gofetch.py   # ed short for 'edit'
     bg gofetch()
     jobs[0].status
     jobs[0].result

     ipython -p physics      # with unit
     e.convertToUnit('J')
     ipython -pylab
*** how to look at modules that has been loaded
    import sys
    sys.modules
*** how to know the type of a python object
    type(object)
    e.g. a = [1,2,3]
    type(a) 			# return <type 'list'>
    isinstance(a, type(a))	# return True
*** getattr and callable
    func = getattr(self, 'set_'+k, None) # same as calling self.set_*k*
    if func is None or not callable(func): raise AttributeError("Unknown
    Prop")
    func(v)
*** the difference between __call__ and __init__
    class A:
    def __init__(self):
    print "init"
    def __call__(self):
    print "call"
    # then,
    a = A() 			# print init
    a()				# print call

** sed
*** multiple sed replacement in one command
use -e
find . -type f -exec sed -i '' -e s/Red/$color1/g -e s/Blue/$color2/g {} \;
** R
*** Data IO
****** read.csv
read.csv is identical to read.table except that the default separator is “,” and header=TRUE
t<-read.csv('2012_04_16_endosymbiosis_in_gamma_proteobacteria.csv', header=TRUE)

****** handle large dataset by doing a pilot study of the type of each column
initial <- read.table(“datatable.txt”, nrows=100) # try the first 100 rows first
classes <- sapply(initial, class)
tabAll <- read.table(“datatable.txt”, colClasses=classes)

****** dget and dput
read and write R code files, contain the metadata from R for a single object
> y<-data.frame(a=1,b='a')
> dput(y) # dput to the console
structure(list(a = 1, b = structure(1L, .Label = "a", class = "factor")), .Names = c("a", 
"b"), row.names = c(NA, -1L), class = "data.frame")
> dput(y,file='y.R') # dput to a file
> new.y <- dget('y.R')
> new.y
  a b
1 1 a

****** source and dump
read and  write R code files, contain the metadata from R, possibly for multiple objects
> x<-'foo'
> y<-data.frame(a=1,b='a')
> dump(c('x','y'), file='data.R')
> rm(x,y)
> source('data.R')

****** load and save
read and write workspaces

****** serialize and unserialize
write and read single R object in binary form

****** file connections
file, opens a connection to a file
gzfile, opens a connection to a gzip file
bzfile, opens a connection to a bzip2 file
url, opens a connection to a webpage
> str(file)
function (description = "", open = "", blocking = TRUE, encoding = getOption("encoding"),  raw = FALSE)  
str(file) see the description of a command (in this case “file”)
open is a code indicating
'r' read only
'w' writing
'a' appending
'rb','wb','ab' for binary
con ← file(“foo.txt”, 'r')
data ← read.csv(con)
close(con)
the same as 
data ← read.csv('foo.txt')

******* readLines and writeLines
> con ← gzfile(“words.gz”)
> x ← readLines(con,10) # read in 10 lines.

******* Read in lines of a webpage
con ← url(“http://www.jhsph.edu”,'r')
x ← readLines(con)

**** Print
***** Print without quote “”
> print("a")
[1] "a"
> print("a",quote=FALSE)
[1] a

***** print without array index using cat
> cat("a\n")
a
but in this case, one needs to append “\n”.

the best solution to use C-type printf is to use cat + sprintf
cat(sprintf('%1.3f\t%s\n', a.sorted[i], names(a.sorted)[i]))

*** Manipulate Data
***** how to round a number using floor and ceiling
sapply(vec, floor)
trunc
round
signif
***** Word wrap using strwrap function
sapply(names(t), function(x) paste(strwrap(x,width=40),collapse="\n"))

***** view the class (type) of an object
class(x)
in fact “class” is an attribute of x, see below.

***** access R object's attributes
R attributes can be accessed in two ways, suppose we have an attribute aaa
attr(obj, “aaa”)
or 
aaa(obj)

***** names()
> x<-1:3
> names(x) # no names by default
NULL
> names(x)<-c('foo','bar','norf')
> x
 foo  bar norf 
   1    2    3 
> names(x)
[1] "foo"  "bar"  "norf"

***** explicit type coersion
as.numeric()
as.character()
as.logical()
as.complex()

***** integer and numeric
“1” is numeric and “1L” is integer.

***** Special character NaN and NA and Inf
NA has a class too, there's integer NA and character NA.
NaN is NA, but NA is not NaN.
> x<-c(1,2,NA,10,3)
> is.na(x)
[1] FALSE FALSE  TRUE FALSE FALSE
> is.nan(x)
[1] FALSE FALSE FALSE FALSE FALSE
> x<-c(1,2,NaN,NA,4)
> is.na(x)
[1] FALSE FALSE  TRUE  TRUE FALSE
> is.nan(x)
[1] FALSE FALSE  TRUE FALSE FALSE
****** omit NA
na.omit(dat)

****** filter out NA
> x<-c(1,2,NA,4,NA,5)
> bad<-is.na(x)
> x[!bad]
[1] 1 2 4 5

****** filter out NA for two vectors simultaneously using complete.cases.
> x<-c(1,NA,2,4,NA,5)
> y<-c('a','b',NA,'d',NA,'f')
> good<-complete.cases(x,y)
> good
[1]  TRUE FALSE FALSE  TRUE FALSE  TRUE
> x[good]
[1] 1 4 5
> y[good]
[1] "a" "d" "f"

**** vector
***** how to generate (1,1,1,2,2,2,3,3,3) from (1,2,3)
> rep(c("g1","g2","g3"),times=c(1,3,4))
[1] "g1" "g2" "g2" "g2" "g3" "g3" "g3" "g3"
***** Create an empty vector
x ← vector(“numeric”, length=10)
vector elements are initialized to 0.0
logical vector
x ← c(T,F)
x ← c(TRUE, FALSE)

***** range
x ← 1:20
seq
seq(from = 1, to = 1, by = ((to - from)/(length.out - 1))

***** type coersion in vectors
elements in a vector must be of the same type, there will be implicit type coersion when different types are mixed.
y ← c(1.7, “a”) ## character 1.7 → “1.7”
y ← c(TRUE,2) ## numeric TRUE → 1
y ← c(“a”, TRUE) ## character TRUE → “TRUE”

***** subset a vector
> x<-c('a','b','c','c','d','a')
> x[2]
[1] "b"
> x[1:4]
[1] "a" "b" "c" "c"
> x[x>"a"]
[1] "b" "c" "c" "d"
> u<-x > 'a'
> u
[1] FALSE  TRUE  TRUE  TRUE  TRUE FALSE
> x[u]
[1] "b" "c" "c" "d"

***** vectorized operations
> x <- 1:4; y <- 6:9
> x+y
[1]  7  9 11 13
> x>=2
[1] FALSE  TRUE  TRUE  TRUE
> y==9
[1] FALSE FALSE FALSE  TRUE
> x*y
[1]  6 14 24 36
> x/y
[1] 0.1666667 0.2857143 0.3750000 0.4444444

***** count using sum
> sum(x>4)
count the number of elements in x that are larger than 4

***** vector type check
is.vector()

***** use match to find mapping between two vectors
ma=match(cats, names(t))

**** matrix
****** make a matrix
> m ← matrix(nrow=2, ncol=3)
initialized to “NA”
> m ← matrix(1:6, nrow=2, ncol=3)
> m
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
matrix initialization is “column first” or “columnwise”
> m ← 1:10
> dim(m) ← c(2,5)
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10

****** dimension of a matrix
> dim(m)
[1] 2 5

****** remove the first row
t[-1,]

****** remove several rows
df[-(416:472), ]

****** Sort a data frame by a certain column
sortd=d[with(d, order(-ratio)),]

****** rename column of data frame
names(d)[4]='ratio'

****** view attributes of objects, e.g., names, dimnames, dimensions, class, length are all attributes.
> attributes(m)
$dim
[1] 2 3

****** cbind and rbind
> x ← 1:3
> y ← 10:12
> cbind(x,y)
     x  y
[1,] 1 10
[2,] 2 11
[3,] 3 12
> rbind(x,y) 
  [,1] [,2] [,3]
x    1    2    3
y   10   11   12

****** add two columns rowwise using cbind
ctbl = cbind(tbl[,"Freq"], tbl[,"None"] + tbl[,"Some"])

****** matrix with dimnames (row names, column names)
> m<-matrix(1:4, nrow=2,ncol=2)
> dimnames(m)<-list(c('a','b'),c('c','d'))
> m
  c d
a 1 3
b 2 4

****** subset a matrix
> x<-matrix(1:6,2,3)
> x[1,2]
[1] 3
> x[2,1]
[1] 2
> x[1,]
[1] 1 3 5
> x[,2]
[1] 3 4

by default when a matrix is subsetted, one get a vector instead of a matrix, if one wants a submatrix, specify drop=FALSE
> x[1,]
[1] 1 3 5
> x[1,,drop=FALSE]
     [,1] [,2] [,3]
[1,]    1    3    5

****** vectorized operations
> x <- matrix(1:4, 2, 2); y <- matrix(rep(10, 4), 2, 2) 
> x * y ## element-wise multiplication 
   [,1] [,2] 
[1,] 10 30 
[2,] 20 40 
> x / y 
   [,1] [,2] 
[1,] 0.1 0.3 
[2,] 0.2 0.4 
> x %*% y ## true matrix multiplication 
   [,1] [,2] 
[1,] 40 40 
[2,] 60 60

**** list
List can mix objects of different types
> x ← list(1, “a”, TRUE, 1+4i)
> x
[[1]]
[1] 1

[[2]]
[1] "a"

[[3]]
[1] TRUE

[[4]]
[1] 1+4i

***** A list with name
> x<-list(a=1,b=2,c=3)
> x
$a
[1] 1

$b
[1] 2

$c
[1] 3

***** subset a list
> x<-list(foo=1:4,bar=0.6)
> x[1] # single bracket always return object of the same class, in this case a list.
$foo
[1] 1 2 3 4

> x[ [1] ]
[1] 1 2 3 4
> x$bar
[1] 0.6
> x[ ["bar"] ]
[1] 0.6
> x["bar"]
$bar
[1] 0.6

***** extract multiple elements
> x<-list(foo=1:4,bar=0.6,baz='hello')
> x[c(1,3)]
$foo
[1] 1 2 3 4

$baz
[1] "hello"

***** [[]] can be used to subset elements whose name is determined at runtime
> x<-list(foo=1:4, bar=0.6, baz='hello')
> name<-'foo'
> x[ [name] ]
[1] 1 2 3 4
> x$name
NULL
> x$foo
[1] 1 2 3 4

***** double subset using [[]]
> x<-list(a=list(10,12,14),b=c(3.14,2.81))
> x[ [c(1,3)] ] # the third element of the first element
[1] 14
> x[ [1] ][ [3] ]
[1] 14
> x[ [c(2,1)] ]
[1] 3.14

***** partial matching
> x<-list(aardvark=1:5)
> x$a
[1] 1 2 3 4 5
> x[ ["a"] ]
NULL
> x[ ["a",exact=FALSE] ]
[1] 1 2 3 4 5

***** list coersion
as.list()

***** list type check
is.list()

***** append to list
# Initial list:
List <- list()

# Now the new experiments
for(i in 1:3){
  List[as.character(i)] <- list(sample(1:3))
}


**** factor
***** Ordered or unordered, represent categorical data
> x ← factor(c(“yes”, “no”, “yes”, “no”, “yes”))
> x
[1] yes no  yes no  yes
Levels: no yes

***** frequency count of factor levels
> table(x)
x
 no yes
 2   3

***** see the underlying representation of the factor (really an integer vector)
> unclass(x)
[1] 2 1 2 1 2
attr(,"levels")
[1] "no"  "yes"
> attr(x,'levels')
[1] "no"  "yes"

***** setup baseline level
setup the baseline level, the baseline level would be the first level that is encountered in the “levels” option, otherwise it is determined by the alphabetic order.
> x<-factor(c("yes","no", "yes", "no"), levels=c("yes","no"))
> x
[1] yes no  yes no 
Levels: yes no
if levels is not specified, “no” is before “yes” because “n” is before “y” in the alphabetic order.
> y<-factor(c("yes","no", "yes", "no"))
> y
[1] yes no yes no 
Levels: no yes

***** generate factor levels
> f<-gl(40,10)
generate forty factor levels (each labeled as an integer), each level is repeated 10 times.

**** data frame
heterogenous columns, as opposed to matrix.
***** add new column
>saida["MY_NEW_COLUMN"] <- NA # That creates the new column named "MY_NEW_COLUMN" filled with "NA"
>saida$MY_NEW_COLUMN <- saida$C - saida$D  # As an example, the new column receives the result of C - D
***** build a data frame in a loop, adding row by row
****** method 1
d <- data.frame()
for (i in 1:20) {d <- rbind(d,c(i+i, i*i, i/1))}

similarly
d = NULL

And in the loop:

d = rbind(d, data.frame(x, y, z))
Note: this solution is not efficient.

****** method 2
Build vectors first, dataframe after the loop

x = NULL
y = NULL
z = NULL

in the loop:

x = append(x, runif(1))
...

After loop:

d = data.frame(x, y, z)

****** method 3 (best)

Build empty data frame of desired size beforehand and fill by row

E.g. for 10 rows:
d = data.frame( x=rep(0, 10), y=rep(0,10), z=rep(0,10))

And in the loop (index i):

d[i, ] = c(x, y, z)

***** see the beginning of the data frame
head(df)

***** filter rows of a data frame
df[apply(df > 5, 1, all)]
df[apply(df > 5, 1, any)]
1 means row and “all” and “any” are logical functions.

***** convert data frame to matrix
data.matrix

***** create a data frame
dat <- data.frame(x1 = c(1,2,3, NA, 5), x2 = c(100, NA, 300, 400, 500))
> x<-data.frame(foo=1:4, bar=c(T,T,F,F))
> x
  foo   bar
1   1  TRUE
2   2  TRUE
3   3 FALSE
4   4 FALSE
> nrow(x)
[1] 4
> ncol(x)
[1] 2
> attributes(x)
$names
[1] "foo" "bar"

$row.names
[1] 1 2 3 4

$class
[1] "data.frame"
> attr(x, "row.names")
[1] 1 2 3 4

***** subset out NA using complete.cases (remove NA)
> airquality[1:6,]
  Ozone Solar.R Wind Temp Month Day
1    41     190  7.4   67     5   1
2    36     118  8.0   72     5   2
3    12     149 12.6   74     5   3
4    18     313 11.5   62     5   4
5    NA      NA 14.3   56     5   5
6    28      NA 14.9   66     5   6
> good<-complete.cases(airquality)
> airquality[good,][1:6,]
  Ozone Solar.R Wind Temp Month Day
1    41     190  7.4   67     5   1
2    36     118  8.0   72     5   2
3    12     149 12.6   74     5   3
4    18     313 11.5   62     5   4
7    23     299  8.6   65     5   7
8    19      99 13.8   59     5   8

***** split a data frame by a column into lists
s<-split(airquality, airquality$Month)
str(s)

***** how to remove duplicate rows
df <- data.frame(a = c(1:4, 1:4), 
                 b = c(4:1, 4:1), 
                 d = LETTERS[1:8])

df[!duplicated(df[c("a", "b")]),]
***** number of rows and columns
nrow()
ncol()
higher dimensional matrix:
NROW()
NCOL()

*** control structure
***** if structure
if (<condition1>) {
	## do something
} else if (<condition2>) {
	## do something different
} else {
	## do something different
}

y ← if(x>3) { 10 } else { 0 }

***** for structure
for(i in 1:10) {
	print (i)
}

x ← c(“a”,”b”,”c”,”d”)
for(i in seq_along(x)) {
	print(x[i])
}

for(letter in x) {
	print(letter)
}

for(i in 1:4) print(x[i]) # omit “{}” if only one statement exists

***** loop over a matrix
x ← matrix(1:6, 2, 3)

for(i in seq_len(nrow(x))) {
	for(j in seq_len(ncol(x))) {
		print(x[i,j])
	}
}

***** while
count ← 0
while(count < 10) {
	print(count)
	count ← count + 1
}

***** more than 1 conditions
z ← 5
while(z >= 3 && z <= 10) {
	print(z)
	coin ← rbinom(1,1,0.5)

	if(coin == 1) { ## random walk
		z ← z + 1
	} else {
		z ← z – 1
	}
}

***** repeat (and break)
x0 ← 1
tol ← 1e-8
repeat {
	x1 ← computeEstimate()
	
	if(abs(x1 – x0) < tol) {
		break
	} else {
		x0 ← x1
	}
}

***** next
for(i in 1:100) {
	if (I <= 20) {
		next # skip the first 20 iterations
	}
	# Do something here.
}

**** compact looping
***** lapply – loop apply
loop over a list and evaluate a function on each element
lapply takes a list X, a function FUN, and other arguments via …. if X is not a list, it will be coerced using as.list.
Always return a list, list names are preserved.
> x<-list(a=1:5,b=rnorm(10))
> lapply(x,mean)
$a
[1] 3

$b
[1] 0.3474802
generate uniform random variables using lapply
> x<-1:4
> lapply(x,runif,min=0,max=10)
[ [1] ]
[1] 3.472307

[ [2] ]
[1] 1.314423 3.744869

[ [3] ]
[1] 6.314202 3.900789 6.896278

[ [4] ]
[1] 6.894134 5.549006 4.296244 4.527201

****** use anonymous function
>lapply(x, function(elt) etl[,1])

***** sapply – simplified apply
same as lapply but try to simplify the result
If the result is a list where every element is length 1, then a vector is returned.
If the result is a list where every element is a vector of the same length (>1), a matrix is returned.
If else, a list is returned.
e.g.,
> x<-list(a=1:4, b=rnorm(10),c=rnorm(20,1),d=rnorm(100,5))
> lapply(x,mean)
$a
[1] 2.5

$b
[1] -0.006170834

$c
[1] 0.5080433

$d
[1] 5.022779

> sapply(x,mean)
           a            b            c            d 
 2.500000000 -0.006170834  0.508043328  5.022778795 
but direct application of mean doesn't work
> mean(x)
[1] NA
Warning message:
In mean.default(x) : argument is not numeric or logical: returning NA

***** apply
apply a function over the margins of an array
apply a function to the rows or columns of a matrix
can be used with general arrays, e.g., taking the average of an array of matrices
> str(apply)
function (X, MARGIN, FUN, …
MARGIN is the index of the dimension that will be preserved.

****** find the means of each column
> x<-matrix(rnorm(200),20,10)
> apply(x,2,mean)
 [1]  0.31764279 -0.20359102  0.27766089 -0.11381463 -0.24245208  0.08050356  0.04293477
 [8]  0.42504710  0.17117791 -0.36513407

****** find the sums of each row
> apply(x,1,sum)
 [1] -3.9535466  3.5378914  4.8657229  2.1557528 -1.2801329 -1.6267276  1.4089528
 [8] -5.7330351  0.2595242  3.4015684  3.6012107 -3.0530614  7.9383705  4.2204701
[15]  2.0523599 -4.0927801 -2.7655184 -0.8362684 -4.0963852  1.7951365

****** shortcut functions
Other shortcut functions (which are faster than “apply”)
rowSums = apply(x, 1, sum)
rowMeans = apply(x, 1, mean)
colSums = apply(x, 2, sum)
colMeans = apply(x, 2, mean)

****** quantiles of the rows
Find quantiles of the rows of a matrix, create a matrix of two rows and 20 columns
> apply(x,1,quantile, probs=c(0.25,0.75))
          [,1]       [,2]       [,3]       [,4]       [,5]       [,6]      [,7]
25% -0.9239855 -0.1499241 -0.4175811 -0.3613111 -0.7518307 -0.8027004 -0.915204
75%  0.2370467  0.9444296  1.1890847  0.8302415  0.2443323  0.5562284  1.166624
          [,8]       [,9]     [,10]     [,11]      [,12]       [,13]      [,14]
25% -1.1292202 -1.0858680 -0.609356 -0.291738 -1.5721484 -0.08286563 -0.5172696
75%  0.1851672  0.6926818  1.569856  1.019504  0.9787008  1.38228732  1.3543220
         [,15]      [,16]      [,17]      [,18]      [,19]      [,20]
25% -0.3594793 -1.3583341 -0.6312026 -0.6608781 -1.1903123 -0.4987485
75%  0.7911442  0.5423904  0.1620909  0.4539918  0.6021955  0.8130619

****** collapse the third dimension of a 3-dimensional array
> a<-array(rnorm(2*2*10),c(2,2,10))
> apply(a,c(1,2),mean)
            [,1]       [,2]
[1,]  0.42410042 -0.3661022
[2,] -0.07362168 -0.3439171
or
> rowMeans(a,dims=2)
            [,1]       [,2]
[1,]  0.42410042 -0.3661022
[2,] -0.07362168 -0.3439171

***** tapply – table apply
****** apply a function over subsets of a vector
>str(tapply)
function (X, INDEX, FUN = NULL, ..., simplify = TRUE)
X is a vector
INDEX is a factor or a list of factors (or else they are coerced to factors)
FUN is the function to apply
> x<-c(rnorm(10),runif(10),rnorm(10,1)) 
runif(10): 10 random variables from uniform distribution [0,1].
rnorm(10,1): 10 random variables from normal distribution with mean 1.
> f<-gl(3,10) 
gl: generate levels, in this case 3 levels each repeating 10 times.
> f 
 [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 
Levels: 1 2 3 
> tapply(x,f,mean) 
         1          2          3 
-0.2476370  0.5634356  0.6739376 
“do not simplify” gives back a list:
> tapply(x,f,mean, simplify=FALSE) 
$`1` 
[1] -0.247637 

$`2` 
[1] 0.5634356 

$`3` 
[1] 0.6739376 

****** find group ranges (which returns two values for each factor):
> tapply(x,f,range) 
$`1` 
[1] -1.648938  1.321278 

$`2` 
[1] 0.03362691 0.98146410 

$`3` 
[1] -1.888952  2.737393 

***** split
> str(split) 
function (x, f, drop = FALSE, …)
split a vector into a list of vectors based on a factor
x: vector (or list) or data frame
f: factor or a list of factors
drop indicates whether empty factors levels should be dropped.
> x<-c(rnorm(10),runif(10),rnorm(10,1)) 
> f<-gl(3,10) 
> split(x,f) 
$`1` 
 [1]  0.248778156  1.334741866 -0.881660069  1.628081242  0.386855405 
 [6]  2.029278781 -0.581958243  0.585995546  0.001749236 -0.126356265 

$`2` 
 [1] 0.56698467 0.98970559 0.56405445 0.09636717 0.81920102 0.30759100 
 [7] 0.28073524 0.74154150 0.11624665 0.02004426 

$`3` 
 [1]  0.26474370  0.54080495  1.64569571 -0.03437529  1.76457570  1.21412163 
 [7] -0.30767157  3.32346077  1.78569698  2.65727270 

***** lapply + split (in this case, can be substituted by tapply)
> lapply(split(x,f), mean)
$`1` 
[1] 0.4625506 

$`2` 
[1] 0.4502472 

$`3` 
[1] 1.285433

***** classify and calculate mean
calculate the mean of Ozone and Solar.R based on month
> library(datasets) 
> head(airquality) 
  Ozone Solar.R Wind Temp Month Day 
1    41     190  7.4   67     5   1 
2    36     118  8.0   72     5   2 
3    12     149 12.6   74     5   3 
4    18     313 11.5   62     5   4 
5    NA      NA 14.3   56     5   5 
6    28      NA 14.9   66     5   6
split the entire table by Month
s<-split(airquality, airquality$Month)
> lapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")])) 
$`5` 
   Ozone  Solar.R     Wind 
      NA       NA 11.62258 

$`6` 
    Ozone   Solar.R      Wind 
       NA 190.16667  10.26667 

$`7` 
     Ozone    Solar.R       Wind 
        NA 216.483871   8.941935 

$`8` 
   Ozone  Solar.R     Wind 
      NA       NA 8.793548 

$`9` 
   Ozone  Solar.R     Wind 
      NA 167.4333  10.1800

****** use sapply instead of lapply
> sapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")])) 
               5         6          7        8        9 
Ozone         NA        NA         NA       NA       NA 
Solar.R       NA 190.16667 216.483871       NA 167.4333 
Wind    11.62258  10.26667   8.941935 8.793548  10.1800 
remove missing value when colMeans is called
> sapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")],na.rm=TRUE)) 
                5         6          7          8         9 
Ozone    23.61538  29.44444  59.115385  59.961538  31.44828 
Solar.R 181.29630 190.16667 216.483871 171.857143 167.43333 
Wind     11.62258  10.26667   8.941935   8.793548  10.18000 

****** interaction - split on more than one factors
use interaction function, make cartesian product of the two factors.
> f1<-gl(2,5) 
> f2<-gl(5,2) 
> interaction(f1,f2) 
 [1] 1.1 1.1 1.2 1.2 1.3 2.3 2.4 2.4 2.5 2.5 
Levels: 1.1 2.1 1.2 2.2 1.3 2.3 1.4 2.4 1.5 2.5 
interaction (in this case produced by using “list” in split) can create empty levels
> str(split(x, list(f1, f2)))
List of 10 
 $ 1.1: num [1:6] 0.249 1.335 0.567 0.99 0.265 ... 
 $ 2.1: num(0) 
 $ 1.2: num [1:6] -0.8817 1.6281 0.5641 0.0964 1.6457 ... 
 $ 2.2: num(0) 
 $ 1.3: num [1:3] 0.387 0.819 1.765 
 $ 2.3: num [1:3] 2.029 0.308 1.214 
 $ 1.4: num(0) 
 $ 2.4: num [1:6] -0.582 0.586 0.281 0.742 -0.308 ... 
 $ 1.5: num(0) 
 $ 2.5: num [1:6] 0.00175 -0.12636 0.11625 0.02004 1.7857 ... 

drop empty levels
> str(split(x, list(f1, f2), drop=TRUE)) 
List of 6 
 $ 1.1: num [1:6] 0.249 1.335 0.567 0.99 0.265 ... 
 $ 1.2: num [1:6] -0.8817 1.6281 0.5641 0.0964 1.6457 ... 
 $ 1.3: num [1:3] 0.387 0.819 1.765 
 $ 2.3: num [1:3] 2.029 0.308 1.214 
 $ 2.4: num [1:6] -0.582 0.586 0.281 0.742 -0.308 ... 
 $ 2.5: num [1:6] 0.00175 -0.12636 0.11625 0.02004 1.7857 ... 

***** mapply – multivariate apply
multivariate version of lapply
lapply, sapply and tapply only apply a function to a single element. Mapply applies a function in parallel over a set of arguments.
> str(mapply) 
function (FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)
… contains arguments to apply over
MoreArgs is a list of other arguments to FUN
> mapply(rep,1:4,4:1) 
is equivalent to
> list(rep(1,4), rep(2,3), rep(3,2),rep(4,1))
[[1]] 
[1] 1 1 1 1 

[[2]] 
[1] 2 2 2 

[[3]] 
[1] 3 3 

[[4]] 
[1] 4 
another examle of “instant vectorization”
> noise<-function(n,mean,sd){rnorm(n,mean,sd)}
> mapply(noise,1:5,1:5,2) 
[[1]] 
[1] -0.5250608 

[[2]] 
[1] 4.684903 1.778944 

[[3]] 
[1] 7.540316 5.528719 5.501906 

[[4]] 
[1] 5.190458 5.318942 2.206801 3.286727 

[[5]] 
[1] 2.245433 1.933995 8.561300 4.059340 2.559799 
is equivalent to
list(noise(1,1,2), noise(2,2,2), noise(3,3,2), noise(4,4,2),noise(5,5,2))

*** Functions
****** see all formal arguments of a function
formals

****** check out what arguments are needed
args(function)

****** arguments matching
> args(sd)
function (x, na.rm = FALSE) 
> mydata ← rnorm(100)
> sd(mydata)
> sd(x = mydata)
> sd(x = mydata, na.rm = FALSE)
> sd(na.rm = FALSE, x = mydata)
> sd(na.rm = FALSE, mydata)

****** lazy evaluation
f ← function(a, b) {
	a^2
}
f(2) # function call OK!

f ← function(a, b) {
	print(a)
	print(b)
}
f(45) # function call Error!

… argument
… is often used when extending another function and you don't want to copy the entire argument list of the original function
myplot ← function(x, y, type=”l”, …) {
	plot(x, y, type = type, …)
}

****** generic function
> mean
function (x, ...) 
UseMethod("mean")

******* "..." usage
when the number of arguments is unknown one should use … and any arguments that appear after … on the argument list must be named explicitly and cannot be partially matched.
> args(paste)
function (..., sep = " ", collapse = NULL) 
> args(cat)
function (..., file = "", sep = " ", fill = FALSE, labels = NULL, 
    append = FALSE)

define a generator function to make an optimization function to feed “optim”, “nlm”, and “optimize”
the generator function fix the data argument
make.NegLogLik <- function(data, fixed=c(FALSE, FALSE)) {
	params <- fixed
	function(p) {
		params[!fixed] <- p
		mu <- params[1]
		sigma <- params[2]
		a <- -0.5 * length(data) * log(2*pi*sigma^2)
		b <- -0.5 * sum((data-mu)^2) / (sigma^2)
		-(a+b)
	}
}

******* to use generator function to make a negative log likelihood function
> set.seed(1); normals<-rnorm(100,1,2)
> nLL<-make.NegLogLik(normals)
> nLL
function(p) {
        params[!fixed] <- p
        mu <- params[1]
        sigma <- params[2]
        a <- -0.5 * length(data) * log(2*pi*sigma^2)
        b <- -0.5 * sum((data-mu)^2) / (sigma^2)
        -(a+b)
    }
<environment: 0xb647a480> # the pointer to the defining environment
> ls(environment(nLL))
[1] "data"   "fixed"  "params"

******* to use nLL, with initial value of mu and sigma
> optim(c(mu=0, sigma=1), nLL)$par
      mu    sigma 
1.218239 1.787343 

fixing sigma = 2
> nLL<-make.NegLogLik(normals, c(FALSE,2))
> optimize(nLL,c(-1,3))$minimum
[1] 1.217775

fixing mu = 1
> nLL<-make.NegLogLik(normals, c(1,FALSE))
> optimize(nLL,c(1e-6,10))$minimum
[1] 1.800596

******* plot log likelihood function against mean
> nLL<-make.NegLogLik(normals,c(1,FALSE))
> x<-seq(1.7,1.9,len=100)
> y<-sapply(x,nLL)
> plot(x,exp(-(y-min(y))),type='l')

******* plot log likelihood function against sigma
> nLL<-make.NegLogLik(normals, c(FALSE,2))
> x<-seq(0.5,1.5,len=100)
> y<-sapply(x,nLL)
> plot(x,exp(-(y-min(y))),type="l")

***** anonymous function
suppose we have x
> x<-list(a=matrix(1:4,2,2),b=matrix(1:6,3,2))
> x
$a
     [,1] [,2]
[1,]    1    3
[2,]    2    4

$b
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
and we want to grab the first column of the two matrices, we can use an anonymous function
>lapply(x, function(elt) etl[,1])

use invisible to refrain auto-printing (but still return the object)
printmessage <- function(x) {
	if (x>0)
		print(“x is greater than zero”)
	else
		print(“x is less than or equal to zero”)
	invisible(x)
}

“print” function will return the string it prints
*** Statistical tests

Wilcoxon
wilcox.test(t$enzymes[t$symbiotic.!='endosymbiotic'], t$enzymes[t$symbiotic.=='endosymbiotic'], alternative='greater')

wilcox.test(t$Qnorm[t$symbiotic.!='endosymbiotic'], t$Qnorm[t$symbiotic.=='endosymbiotic'], alternative='greater')

wilcox.test(t$V3[t$V2=='Obligate'], t$V3[t$V2=='Facultative'], alternative='less')

Pearson's Chi-squared test of independence on a contingency table
chisq.test(table(survey$Smoke, survey$Exer))

chisq.test(x[,2],p=dbinom(x[,1],5,0.5))

Spearman's Correlation
cor.test(method='spearman')

**** sample random variables
set.seed
> set.seed(1)
> rnorm(5)
[1] -0.6264538  0.1836433 -0.8356286  1.5952808  0.3295078
> rnorm(5)
[1] -0.8204684  0.4874291  0.7383247  0.5757814 -0.3053884
> set.seed(1)
> rnorm(5)
[1] -0.6264538  0.1836433 -0.8356286  1.5952808  0.3295078

***** sample from vector with replacement
sample(vec,10,replace=TRUE)     sample from a vector
***** uniform distribution
sample
> set.seed(1)
> sample(1:10,4)
[1] 3 4 5 7
> sample(1:10,4)
[1] 3 9 8 5
> sample(letters, 5)
[1] "q" "b" "e" "x" "p"
> sample(1:10) # permutation
 [1]  4  7 10  6  9  2  8  3  1  5
> sample(1:10)
 [1]  2  3  4  1  9  5 10  8  6  7
> sample(1:10, replace=TRUE) # sample with replacement (same number may appear multiple times)
 [1] 2 9 7 8 2 8 5 9 7 8

***** normal distribution
rnorm(n, mu, sigma)
r: random number generation
sample n random variable from normal distribution
rnorm(n, mean = 0, sd = 1, log = FALSE) 
x <- rnorm(10) # generate 10 random variables from a normal distribution with mean 0 sd 1.
x <- rnorm(10,20,2) # generate 10 random variables from a normal distribution with mean 20 and sd 2.
> summary(x)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  17.39   19.22   19.97   20.05   20.70   23.11 


dnorm
d: density
evaluate density
dnorm (x, mean = 0, sd = 1, log = FALSE)

pnorm
evaluate cumulative distribution function
given value of x compute cumulative probability
pnorm (q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 


qnorm
q: quantile function, given cumulative probability, compute value of x, the inverse function of pnorm.
qnorm (p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)

***** Poisson distribution
rpois
generate random Poisson variate with a given rate
rpois (n, lambda)
> rpois(10,1)
 [1] 0 0 1 1 2 1 1 4 1 2
> rpois(10,2)
 [1] 4 1 2 0 1 1 0 1 4 1
> rpois(10,20)
 [1] 19 19 24 23 22 24 23 20 11 22
model log.mu = 0.5 + 0.3 * x where x is standard normal distribution
> set.seed(1)
> x<-rnorm(100)
> log.mu<-0.5+0.3*x
> y<-rpois(100,exp(log.mu))
> summary(y)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    1.00    1.00    1.55    2.00    6.00 

ppois
cumulative distribution Poisson distribution
> ppois(2,2)
[1] 0.6766764
> ppois(4,2)
[1] 0.947347
> ppois(6,2)
[1] 0.9954662

***** binomial distribution
rbinom(100, 1, 0.5)

**** other descriptive statistics

frequency count of discrete values
Tabulate frequency counts
table(d$numcc)
*** Plotting
graphics package
plot, hist, boxplot

lattice package
xyplot, bwplot, levelplot

grid package
the package lattrice package depend on

grDevices package
code for implementing graphics devices such as X11, PDF, PostScript, PNG, etc.

**** basic plotting
add line using lines
x<-c(1,2,5,10,20,50,100)
y<-sapply(x, log2)
plot(d$numdiffcogs, d$entropy, log='x', xlab='alphabet size', ylab='entropy')
lines(x, y, lty='dashed')

change label size relative to the plot
use argument
cex.lab = 1.5

smoothScatter
***** par change parameters of the plotting
multiple subplots
par(mfrow=c(2,1))

margin
par(mar=c(2,2,1,1))
bottom, left, top, right

xtick positions
xaxp=c(0,136,8)
start, end, number of ticks

***** boxplot
boxplot() 带error bar的盒装图

boxplot(list(d$numhsp[d$density < 0.5], d$numhsp[d$density >= 0.5]), log='y', names=c("density < 0.5", "density >= 0.5"), ylab="connected component size", cex.lab=1.4, cex.axis=1.4)
cex.axis change the size of label on x axis
names
labels on x-axis

another way to boxplot against some factor
boxplot(envcnt ~ gltrunc12, data=d, xlab='number of gains and losses')

**** lattice plotting
library(lattice)
package ? Lattice
library(help=lattice)
data(environmental)
?environmental
head(environmental)
xyplot(ozone ~ radiation, data=environmental)
xyplot(ozone ~ radiation, data=environmental, main=”Ozone vs. Radiation”)

*** Others
Get working directory
> getwd()

list file in the working directory
> dir()

list object in the work space
> ls()

look for help
?chisq.test

display the internal structure of an R object using str
diagnostic function and alternative to “summary”
> str(str)
function (object, ...)
> str(lm)
function (formula, data, subset, weights, na.action, method = "qr", 
    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, 
    contrasts = NULL, offset, ...)  
> str(ls)
function (name, pos = -1, envir = as.environment(pos), all.names = FALSE, 
    pattern)  
> x<-rnorm(100,2,4)
> summary(x)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
-6.0210 -0.6476  2.0160  2.1340  4.5160 14.4300 
> str(x)
 num [1:100] -0.61 3.586 2.446 -0.265 2.366 …

Scoping rules
to see the search paths (and their priorities). The global environment (or the user's workspace) is always the first on the search list and base package is always the last.
> search()
 [1] ".GlobalEnv"        "tools:rstudio"     "package:stats"    
 [4] "package:graphics"  "package:grDevices" "package:utils"    
 [7] "package:datasets"  "package:methods"   "Autoloads"        
[10] "package:base"   
library() put the package to the second position of the search list
> library(lattice)
> search()
 [1] ".GlobalEnv"        "package:lattice"   "tools:rstudio"    
 [4] "package:stats"     "package:graphics"  "package:grDevices"
 [7] "package:utils"     "package:datasets"  "package:methods"  
[10] "Autoloads"         "package:base"    
function and non-function are separated. One can have a function c and a object called c simultaneously.

Lexical scoping
the values of free variables are searched for in the environment in which the function was defined.
A function + an environment = a closure or function closure.
Keep looking back in the search list.
> f<-function(x) {x*x}
> environment(f)
<environment: R_GlobalEnv>
> parent.env(environment(f))
<environment: package:lattice>
attr(,"name")
[1] "package:lattice"
attr(,"path")
[1] "/usr/lib/R/library/lattice"

free variables are searched in the parent closure
> make.power <- function(n) {pow <-function(x) {x^n}; pow}
> cube <- make.power(3)
> square <- make.power(2)
> cube(3)
[1] 27
> square(3)
[1] 9
> ls(environment(cube))
[1] "n"   "pow"
> get('n',environment(cube))
[1] 3
> ls(environment(square))
[1] "n"   "pow"
> get('n',environment(square))
[1] 2

debugging tools
Message, warning, error, condition
condition: a generic concept for indicating that something unexpected can occur; programmers can create their own conditions.
Warning
>log(-1)
[1] NaN
Warning message: 
In log(-1) : NaNs produced 

traceback
prints out the function call stack, does nothing if there's no error
> mean(x)
Error in mean(x) : object 'x' not found
> traceback()
1: mean(x)
or
> lm(y~x)
Error in eval(expr, envir, enclos) : object 'y' not found
> traceback()
7: eval(expr, envir, enclos)
6: eval(predvars, data, env)
5: model.frame.default(formula = y ~ x, drop.unused.levels = TRUE)
4: model.frame(formula = y ~ x, drop.unused.levels = TRUE)
3: eval(expr, envir, enclos)
2: eval(mf, parent.frame())
1: lm(y ~ x)

debug
flag a function for “debug” mode which allows you to step through execution of a function one line a time
n: next line
Q: quit
c: continue without single stepping
where: show call stack
> debug(lm)
> lm(y~x)
debugging in: lm(y ~ x)
debug: {
    ret.x <- x
    ret.y <- y
…
    if (!qr) 
        z$qr <- NULL
    z
}
Browse[2]> n
debug: ret.x <- x
Browse[2]> n
debug: ret.y <- y

browser
suspend the execution of a function wherever it is called and puts the function in debug mode
the browser is just like your R work space (interactive shell)

trace
allows you to insert debugging code into a function a specific places

recover
allows you to modify the error behavior so that you can browse the function call stack
> options(error=recover)
> read.csv("nosuchfile")
Error in file(file, "rt") : cannot open the connection
In addition: Warning message:
In file(file, "rt") :
  cannot open file 'nosuchfile': No such file or directory

Enter a frame number, or 0 to exit   

1: read.csv("nosuchfile")
2: read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill 
3: file(file, "rt")

Selection: 1
select a level in the call stack to see around, in this case, read.csv, for example. The control is handed over to browse.
Called from: top level 
Browse[1]> Q

*** data IO
**** read.table
***** commonly used arguments
****** file
****** header
****** sep
       default to space
****** colClasses=c("character", "integer", "numeric")
       this may speed the data import
       e.g., colClasses=”numeric”
****** nrows
****** comment.char
       default to “#”, set comment.char=”” if there are no commented lines in your file.
****** skip
       the number of lines to skip from the beginning
****** stringsAsFactors
       hould character variables be coded as factors?
***** read.table("clipboard")
      Read table from clipboard
      read.table(“clipboard”)
      One can copy a region in Excel then use this command to import to R.
***** handle large data
      d.full=read.table('/home/wanding/sync/project_HGT/data2/2013_02_04_eval2alen.tab', header=T, comment.char="", colClasses=c("character", "integer", "numeric"), stringsAsFactors=F)
*** basic graphics
**** common arguments
***** cex
****** cex.lab
       change label size relative to the plot
       magnification of x and y labels relative to cex
       cex.lab = 1.5
****** cex.axis
       magnification of axis annotation relative to cex
***** xlim, ylim - x, y plotting range
      plot(x, y, log='y', ylim=c(10, 20))
***** pch - plotting character
      plot character/marker/symbol
      +: 3
***** col - border color of the symbol
***** bg - fill color of the symbol
***** xlab, ylab - put labels
**** smoothScatter
     smoothScatter(d$oldfitness, d$newfitness, xlab='iJR904 fitness', ylab='iAF1260 fitness', cex.lab=1.5)
***** making a log scale smoothScatter
      smoothScatter(x, log(y))
      instead of using
      smoothScatter(x, y, log='y')
      see
      https://stat.ethz.ch/pipermail/r-help/2009-July/205922.html
**** plot
     plot(x,y) scatter plot
     plot(... type="h") histogram
     plot(... type="p") point graph
     plot(... type="l") line graph
     plot(... type="b") both line and points
     plot(density(x)) density plot
**** lines
     add line using lines
     x<-c(1,2,5,10,20,50,100)
     y<-sapply(x, log2)
     plot(d$numdiffcogs, d$entropy, log='x', xlab='alphabet size', ylab='entropy')
     lines(x, y, lty='dashed')
***** lty - line type
      dashed: 2
***** lwd - line width
      relative to the default (default=1). 2 is twice as wide.
**** abline
     abline(0, 1, lty='dashed')
**** title
     title(main = NULL, sub = NULL, xlab = NULL, ylab = NULL)
**** par
***** mfrow and mfcol
      multiple subplots
      par(mfrow=c(1,1))
*** other
**** clear workspace
     rm(list=ls())
*** old

x<-seq(-pi,pi,len=65)
plot(x,sin(x),type="l",col=2,xlab=expression(phi),ylab=expression(f(phi)))
abline(h=-1:1,v=pi/2*(-6:6),col="gray90")
lines(x,cos(x),col=3,lty=2)
ex.cs1<-expression(plain(sin)*phi,paste("cos",phi))	##expression vector
util::str(legend(-3,.9,ex.cs1,lty=1:2,plot=FALSE,adj=c(0,.6)))	##compactly display the internal structure of a R object.


/*FMARK_END*/

barplot() 柱状图/*FMARK_START*/

/*FMARK_END*/


hist() 直方图/*FMARK_START*/
hist(w1$vals)
hist(w1$vals,breaks=2)	breaks defines how many hists there are.
hist(w1$vals,breaks=4)
hist(w1$vals,breaks=12)
hist(w1$vals,breaks=12,xlim=c(0,10))	xlim defines the ranges of the x axis for display
hist(w1$vals,breaks=12,xlim=c(-1,2))
/*FMARK_END*/

stripchart()    窄带图/*FMARK_START*/
stripchart(w1$vals)
stripchart(w1$vals,method="stack")
stripchart(w1$vals,method="jitter")
stripchart(w1$vals,vertical=TRUE)
stripchart(w1$vals,vertical=TRUE,method="jitter")
stripchart(w1$vals,method="stack",main='Leaf BioMass in High CO2 Environment',xlab="BioMass of Leaves"
add title and label: title('Leaf BioMass in High CO2 Environment',xlab='BioMass of Leave')
/*FMARK_END*/

matplot() 矩阵图/*FMARK_START*/
x<-seq(-4,4,len=101)
y<-cbind(sin(x),cos(x))
matplot(x,y,type="l",xaxt="n",main=expression(paste(plain(sin)*phi," and ",plain(cos)*phi)),ylab=expression("sin"*phi,"cos"*phi),#only 1st is taken
xlab=expression(past("Phase Angle ",phi)),
col.main="blue")
axis(1,at=c(-pi,-pi/2,0,pi/2,pi),labels=expression(-pi,-pi/2,0,pi/2,pi)) add an axis to a plot.
/*FMARK_END*/

# Venn's diagram 维恩图/*FMARK_START*/
===================
library(limma)
hsb2<-read.table("http://www.ats.ucla.edu/stat/R/notes/hsb2.csv",sep=',',header=T)
attach(hsb2)
hw<-(write>=60) # the result is an array of TRUE or FALSE.
hm<-(math>=60)  # the result is an array of TRUE or FALSE.
hr<-(read>=60)  # the result is an array of TRUE or FALSE.
c3<-cbind(hw,hm,hr)
a<-vennCounts(c3)
vennDiagram(a)
===================
vennDiagram(a,include="both", names=c("High Writing","High Math","High Reading"), cex=1, counts.sol="red")
g1<-c(rep(0,6),rep(1,3))
g2<-c(rep(1,6),rep(0,3))
g<-cbind(g1,g2)
c<-vennCounts(g)
vennDiagram(c)
/*FMARK_END*/

组合图/*FMARK_START*/
1. Combine hist and stripchart
hist(w1$vals,main='Leaf BioMass in High CO2 Environment',xlab='BioMass of Leaves',ylim=c(0,16))
stripchart(w1$vals,add=TRUE,at=15.5)

2. Combine hist with boxplot
hist(w1$vals,main='Leaf BioMass in High CO2 Environment',xlab='BioMass of Leaves',ylim=c(0,16))
boxplot(w1$vals,horizontal=TRUE,at=15.5,add=TRUE,axes=FALSE)
boxplot(w1$vals,main='Leaf BioMass in High CO2 Environment',ylab="BioMass of Leaves",horizontal=TRUE)
boxplot(tree$STBM~tree$C)	tree$C is a factor vector.
/*FMARK_END*/

legend()  图例 /*FMARK_START*/
legend(-3,.9,ex.cs1,lty=1:2,col=2:3,adj=c(0,.6))	##the components of each vector have to match. 
##col: the color vector of each component.
##lty: the line type 0=blank 1=solid 2=dashed 3=dotted 4=dotdash,5,longdash,6,twodash.
op<-par(bg="white")	get an opaque box for the legend

My example for legend:
legend("topright",expression(paste("sin",phi),paste("cos",phi)),lty=1:1,col=c(1,2),title="right")
Or we can designate the character on the line with exact coordinate of the legend by specifying pch:
legend(-3,.9,expression(paste("sin",phi),paste("cos",phi)),lty=1:1,col=c(1,2),title="right",pch=2)


legend("topright","(x,y)",pch=1,title="right")
legend(-1,1.9,c("sin","cos","tan"),col=c(3,4,6),text.col="green4",lty=c(2,-1,1),pch=c(-1,3,4),merge=TRUE,bg='gray90')
/*FMARK_END*/

mtext() add text into the margin of a plot./*FMARK_START*/
mtext(text,side=,line=,outer=FALSE,at=NA,adj=NA,padj=NA,cex=NA,col=NA,font=NA,...)
side=1(bottom),2(left),3(top),4(right)
line: Margin line starting at 0 counting outwards.
outer=TRUE,use outer margins if available.
adj,padj: used to adjust the location of the text.
col: the color to use,e.g. col=100 or col="darkred"
font: the font for text
/*FMARK_END*/

Hershey: the special font vector/*FMARK_START*/
demo(Hershey)   see how to draw special font in detail
/*FMARK_END*/

layout.show()  显示layout分布和编号。

colors(): list all the colors available and their index

/*FMARK_END*/

Statistics/*FMARK_START*/

描述性统计量
sum mean median var sd min max range quantile summary 

set.seed(N)     set up the sampling seed



Binomial distribution /*FMARK_START*/
dbinom(x,size,prob)	size is the number of trials, prob is the probability of success of each trial
pbinom(q,size,prob)
qbinom(p,size,prob)	p is the number of successes among size
rbinom(p,size,prob)
/*FMARK_END*/

Normal distribution:/*FMARK_START*/
help(Normal)
1. dnorm(0,mean=0,sd=1)	returns the height of the probability distribution at each point. Assume zero-mean and one-standard deviation
x<-seq(from=-10,to=10,by=0.1)
y<-dnorm(x,mean=0,sd=1)
plot(x,y)
2. pnorm(v,mean=0,sd=1)	calculate the probability that a normally distributed random number will be less than v(cummulative probability).
3. qnorm(v,mean=0,sd=1) calculate the number whose cummulative probability is v.
4. rnorm(n,mean=0,sd=1)	gives n random numbers following the normal distribution.
Two generic functions: qqnorm(y) and qqline(y) provide a normal QQ plot of the values in 'y'.qqline is a line connecting the first and the third quartiles.
/*FMARK_END*/

Build contigency table:/*FMARK_START*/
table(vec)
table(vec,vec2) 2-d contingency table(matrix)
/*FMARK_END*/

/*FMARK_END*/

Data manipulation/*FMARK_START*/
string manipulation/*FMARK_START*/
concatenate two string
paste("wan","ding")
substring:
substring("wanding",1,3)
gives "wan"


combine math and numeric variable:/*FMARK_START*/
plot(1:10,type="n",xlab="",ylab="",main="plot math & numbers")
theta<-1.23;
mtext(bquote(hat(theta)==.(theta)))
for(i in 2:9)
	text(i,i+1,substitute(list(xi,eta)==group("(",list(x,y),")"),
		list(x=i,y=i+1)))

plot(1:10,1:10)
text(4,9,expression(hat(beta)==(X^t *X)^{-1}*X^t*y))	add text to a plot.
text(4,8.4,"expression(hat(beta)==(X^t*X)^{-1}*X^t*y)",cex=.8)
text(4,7,expression(bar(x)==sum(frac(x[i],n),i==1,n))
text(4,6.4,"expression(bar(x)==sum(frac(x[i],n),i==1,n))",cex=.8)
text(8,5,expression(paste(frac(1,sigma*sqrt(2*pi))," ",plain(e)^{frac(-(x-mu)^2,2*sigma^2)})),cex=1.2)

text(x,y,labels,adj=,pos=,offset=,vfont=,cex=,col=,font=)
	adj: adjustment of relative position of the text
	pos=1,2,3,4,correspond to below, left, above, right. This overrides adj
	cex= a value with 1 for normal size. for minization and enlargement
/*FMARK_END*/
/*FMARK_END*/

array manipulation /*FMARK_START*/
x[1:3]	显示第1，2，3个元素组成的子数组
x[-c(1,2,3)]	删掉第1，2，3个元素
z<-c(x,y)	合并x,y数组

rev(vec)	reverse the vector

Convert factors to numeric:
t3<-as.numeric(as.character(f))
Or more efficiently, as.numberic(levels(f))[as.integer(f)]

get index of an element in a vector:/*FMARK_START*/
which(vector == element_value)
/*FMARK_END*/
/*FMARK_END*/

matrix manipulation/*FMARK_START*/
remove a column/row of a matrix/*FMARK_START*/
d[,-5] deletes column 5
mat<-matrix(vec3,ncol=2,nrow=5)
mat[-3,]	remove the 3rd row of the matrix
/*FMARK_END*/

get or set the names of rows and columns/*FMARK_START*/
rownames(matrix)
colnames(matrix)

can also use dimnames(matrix),where
"rownames()" is equivalent to "dimnames(matrix)[[1]]"
"colnames()" is equivalent to "dimnames(matrix)[[2]]"
actually [[]] can be substituted by []
dimnames() is built for high dimensional matrix e.g. 3,4...
/*FMARK_END*/

build matrix by column/*FMARK_START*/
matrix <- cbind(column1 = 3, column2 = c(4:1,2:5))
/*FMARK_END*/

apply on rows/columns/*FMARK_START*/
col.sums <- apply(matrix,2,sum)
row.sums <- apply(matrix,1,sum)/*FMARK_END*/


data frame manipulation/*FMARK_START*/
change the header of a dataframe:
names(d2)<-d[,1]

change the names of a data.frame:
colnames(data)<-c('Apple','Orange')
colnames(data)<-"Q"

/*FMARK_END*/

读入数据：/*FMARK_START*/

1. data1=read.table("/home/wanding/myfile",header=T)

2. read multiple graphs:
files <- list.files("<your-directory-here>")
graphs <- lapply(files, read.graph, format="<your-format>")


/*FMARK_END*/

保存数据：/*FMARK_START*/
sink("/home/wanding/myfile.csv")
datafile
sink()
完成
或者write.table(datafile,file="/home/wanding/myfile.csv")
/*FMARK_END*/

保存(输出)图像：/*FMARK_START*/
write into file:
pdf(file="my2.pdf")
<do my plot,which won't display>
dev.off()
/*FMARK_END*/

edit(dataframe)	手工修改dataframe

/*FMARK_END*/

Scripting/*FMARK_START*/
argument passing/*FMARK_START*/
Old style:
R CMD BATCH --args lalala
New style:
./script.R my_arg
Then:
args<-(commandArgs(TRUE))
args
"lalala"
/*FMARK_END*/
attach(data1)	使data1的列自动储入，无须data1$...
get or set working directory/*FMARK_START*/
getwd()
setwd(dir)
/*FMARK_END*/
variable substitution/*FMARK_START*/
a<-2
bquote(a==.(a)) give "a == 2"
/*FMARK_END*/
assertion/*FMARK_START*/
stopifnot()/*FMARK_END*/
/*FMARK_END*/

R system administration/*FMARK_START*/
data()	看built-in system data
history()	View the history
library(help="utils")	view a complete list of utility functions

use html help
options(htmlhelp=FALSE)

change prompt:
options(prompt="R> ")

list.files(pattern=".pairs")	list all the files satisfying some pattern in the current directory.
/*FMARK_END*/



rbind(vec,vec2)	We get a matrix.
str(table(vec,vec2))	view internal structure: str();
vec3<-1:10
matrix(vec3,ncol=2,nrow=5)	construct a matrix from a 1d vector
matrix(vec3,ncol=2,nrow=5,byrow=TRUE)
dim(vec3)<-c(5,2)	cast the dimension of a 1d vector. Same effect as above.
See ?Extract

[.factor subsetting factors

remove the factor attribute:
attributes(t3$TF.fraction)<-NULL

na.omit(dataframe);
options("na.action");

similarly jpeg(),png(),...

example(rect)	view example of function rect


Note: 假设A,B是两列factor，则A:B是nested factor

cor(tree$STBM,tree$LFBM)	calculate the correlation coefficient.R NOT R^2

qqnorm(w1$vals,main="Normal Q-Q Plot of the Leaf Biomass",xlab="Theoretical Quantiles of the Leaf Biomass",xlab="Theoretical Quantiles of the Leaf Biomass",ylab="Sample Quantiles of the Leaf Biomass")
	to check if your data(w1$vals) is normally distributed or not.
qqline(w1$vals) add the theoretical line.

mnemonics:d for density; p for probability, q is inverse of p, r is the random number.

t-distribution(Assume mean zero and standard deviation one):
help(TDist)
dt(x,df=50)	note that: df is the degree of freedom of the distribution, while the length of x is the number of sample.They are different.
pt, qt and rt are like normal distribution

help(Chisquare)
dchisq(x,df=10)
pchisq(2,df=10)
qchisq(0.05,df=10)
rchisq(3,df=10)


min(a,b)	find the minimum of all the elements in either a or b.
pmin(a,b)	return the vector of minimal element in corresponding position in a and b

To create a dataframe:
bubba<-data.frame(first=a second=b f=levels)

One-way table:
Method One(from a factor vector):	a<-factor(c("A","A","B","A","B","B","C","A","C"))
					results<-table(a)
Method Two(from a matrix):	occur<-matrix(c(4,3,2),ncol=3,byrow=TRUE)
				colnames(occur)<-c("A","B","C")
				occur<-as.table(occur)

Two-way table:
Method One:
a<-c("Sometimes","Sometimes","Never","Always","Always","Sometime","Sometimes","Never")
b<-c("Maybe","Maybe","Yes","Maybe","Maybe","No","Yes","No")
results2<-table(a,b)

Method Two:
sexsmoke<-matrix(c(70,120,65,140),ncol=2,byrow=TRUE)
rownames(sexsmoke)<-c("male","female")
colnames(sexsmoke)<-c("smoke","nosmoke")
sexsmoke <- as.table(sexsmoke)

make something a factor:
something<-factor(something)

if something is a factor, then typing "something" will give levels information.Besides, typing "attributes(something)"will have "levels" option. So we can use levels(something)

Summary will print out the statistics of all columns in the dataframe
summary(argument)	print the five point descriptive statistics if the argument is a factor
summary(factor)	print the frequency of each key if the argument is NOT a factor

add the library path:
in ~/.Renviron add "R_LIBS="home/wan/lib/R"

read.csv(comma separated values) This uses data.frame to store data.
heisenberg<-read.csv(file="simple.csv",head=TRUE,sep=",") head indicates whether or not the first row is a set of labels.
summary(heisenberg)
names(heisenberg) gives the names of the variables
attributes(tree)	to list all the variables of the data.frame

read.fwf	to read fixed width file

power.law.fit(table(degree_vec))

degree_vec<-degree(g,mode=c("total"))
sort(degree_vec,decreasing=TRUE)

levels(factor(degree_vec))

plot(t,log="xy")

lec<-leading.eigenvector.community(g)
modularity(g,lec$membership)

write.table(mod,file="modularity_table")

lalala<-scan("filename",what=character(0))

apply(X,MARGIN,FUN) 

tapply(vector,factor,FUN)
print(tapply(as.vector(iris[,i]),factor(iris[,5]),mean))

seq1<-seq(from=1,to=50,by=2)

dev.copy2pdf()
dev.eps2pdf()

R CMD BATCH myfirst.r

x11()
dev.copy(device=...)
mtext()

batch<-rep(c("m10s"),times=5)
batchf<-factor(batch)

linear regression:
Before doing linear regression, one have to check if the factor attribute of the argument is removed or not first.
fm<-lm(y~x,data=dummy)
fit<-lm(rate~year)
To get the interest rate in year 2015:	Note that one should use two square braces to get the number.
fit$coefficients[[2]]*2015+fit$coefficients[[1]]
residuals(fit)	the residuals of the fit. By definition is the difference between the each data point with the predicted value.
abline(fit)	add fitted line onto the data plot.
summary(fit)	can get the result of F-test.
fm$call
fm$coefficient: Intercept & x

file.show(filepath)	display the file indicated in the filepath

search the system for the full path of a file
system.file("data","morley.tab",package="datasets")

max(fastgreedy.community(rewire(g,niter=10000))$modularity)

read.table()	read an entire data frame

Lst<-list(name_1=object_1,...,name_m=object_m)	construct a new list

Lst<-c(list.A, list.B, list.C)	concatenate lists

Lst<-list(name="Fred",wife="Mary",no.children=3,child.ages=c(4,7,9))
Lst[[1]] is equivalent to Lst$name.
Lst[[2]] is equivalent to Lst$wife.
Lst[[3]] is equivalent to Lst$no.children
Lst[[4]][1] is equivalent to Lst$child.ages[1]

table(statef)	returns the frequency table of factor statef
to calculate the mode you can names(-table(state))
equivalent to tapply(statef, statef, length)

diag(v) gives a diagonal matrix with elements of the vector as the diagonal entries.
diag(M) gives the vector of main diagonal entries of M.
diag(k) gives a k by k identity matrix

cbind(arg_1,arg_2,arg_3,...) forms matrices by binding together matrices horizontally, or column-wise.
rbind(arg_1,arg_2,arg_3,...) forms matrices by binding together matrices vertically, or row-wise.

"*" normal multiplication
"%*%" matrix multiplication
t() matrix transposition
nrow(),ncol() gives the number of rows and columns in the matrix

crossprod(x,y)==t(x)%*%y

array(data_vector,dim_vector)	recycling rule applies for data_vector
x<-array(1:20,dim=c(4,5))

for any array Z, its dimension vector is dim(Z)

column-major order:	the first subscript moving fastest

dim(z)<-c(3,5,100)

qt()		 to find the percentage points of the appropriate t-distributions

stderr<-function(x) sqrt(var(x)/length(x))

tapply(incomes,statef,mean)

factor(...)
levels(factor)

plot()
summary()
display or react to an argument according to its class
unclass()	remove the class attribute of an object

attr(z,"dim")<-c(10,10)		treat z as a 10 by 10 matrix

truncate methods:
#1: reassign: alpha<-alpha[2*1:5]
#2: length(alpha)<-3

e<-numeric()		create an empty numeric vector
as.character(z)	convert to character
as.integer(z)	convert to integer

list of empty character string vector is listed as character(0) and the empty numeric vector as numeric(0)

mode(objects)
length(objects)
attributes(objects)

y[y<0]<- -y[y<0]
has the same effect as y<- abs(y)

names(...)
e.g. 
fruit<-c(5,10,1,20)
names(fruit)<-c("orange","banana","apple","peach")


y<-x[-(1:5)] gives y all but the first five elements of x

c(2,3)[rep(c(2,1),times=2)] gives 3 2 3 2

x[6]	select the sixth component of x
x[1:10] select the first 10 components of x

y<-x[x<10]
y<-x[!is.na(x)]
(x+1)[(!is.na(x)) & x>0] ->z
A<-c(1,2,3)
B<-c(0,1,0)
change A's element to 0 if B's element is 1: A[B==1]<-0

labs<-paste(c("X","Y"),1:10,sep"")
== c("X1", "Y2", "X3", "Y4", "X5", "Y6", "X7", "Y8", "X9", "Y10")
the recycling of short lists takes place here.

\ is used to escape
\n newline
\t tab
\b backspace
see ?Quotes

is.na(x)
is.nan(x)

& for "and"
| for "or"
! for "negation"

temp <- x > 13

TRUE(1) FALSE(0) NA NaN	(NA for not available;NaN for Not a Number)

y <- rep(x,times=5)
y<- rep(x,each=5)

z<- c(1:10) 2*1:15 seq(from=..., to=...)
seq(-5,5,by=.2) seq(length=51,from=-5,by=0.2)
z<- c(1:3,NA)

sqrt(-17+0i)

descriptive statistics:
max(x),min(x),mean(x),range(x),sum(x),prod(x),length(x),
var(x),sort(x),sort.list(),order(),quantile(x),sd(x)

To change libPath temporarily:
.libPaths(c("/usr/lib/R/library","/usr/share/R/library"))

1/x: the reciprocal of all the members of x.
x+1: all the members of x plus 1
data are stored .RData
command lines are stored .Rhistory

sometimes, "=" equals "<-"

source("commands.R")
sink("record.lis")	divert output to record.lis
sink()

#is comment symbol

example(topic)

?help.search("chi-square")	fuzzy-match search for chi-square
help.search(igraph)	to search for topic in documents
help("[[")
?"[["
vignette("sandwich")	## a brief introduction to the package sandwich


help(solve)

write.graph(g,"./new.pairs",format=c("edgelist"))

rm(x,y)

remove.packges(c("igraph"),lib=file.path("/usr/lib/R/library"))

install.packages("/home/wanding/download/igraph_0.5.1.tar.gz",repos=NULL)

install packages(c("igraph"),lib=file.path("/home/wan/lib/R/")) to install to local library
library(igraph,lib.loc=c("/home/wan/lib/R/"))	to load the library

read.graph("elst",format=c("edgelist"),directed=FALSE)

library(igraph)	load igraph library

help.start()
help(read.csv,htmlhelp=FALSE)
help.start(browser=c("firefox"))

.libPaths() 

getOption("defaultPackages") 

in ~/.Rprofile
It's initially set to the value of the environment variable R_DEFAULT_PACKAGES, e.g. setting R_DEFAULT_PACKAGES=NULL ensures that only package base is loaded.


help="igraph"

ls() "==objects()"
** C++
*** how to use const keyword
**** The C++ 'const' Declaration: Why & How

The 'const' system is one of the really messy features of C++.

It is simple in concept, variables declared with ‘const’ added become constants and cannot be altered by the program, but, in the way is has to be used to bodge in a substitute for one of the missing features of C++, it gets horridly complicated and frustratingly restrictive. The following attempts to explain how 'const' is used and why it exists.

Simple Use of ‘const’

The simplest use is to declare a named constant. To do this, one declares a constant as if it was a variable but add ‘const’ before it. One has to initialise it immediately in the constructor because, of course, one cannot set the value later as that would be altering it. For example,

const int Constant1=96;
will create an integer constant, unimaginatively called ‘Constant1’, with the value 96.

Such constants are useful for parameters which are used in the program but are do not need to be changed after the program is compiled. It has an advantage for programmers over the C preprocessor ‘#define’ command in that it is understood & used by the compiler itself, not just substituted into the program text by the preprocessor before reaching the main compiler, so error messages are much more helpful.

It also works with pointers but one has to be careful where ‘const’ to determine whether the pointer or what it points to is constant or both. For example,

const int * Constant2
declares that Constant2 is variable pointer to a constant integer and

int const * Constant2
is an alternative syntax which does the same, whereas

int * const Constant3
declares that Constant3 is constant pointer to a variable integer and

int const * const Constant4
declares that Constant4 is constant pointer to a constant integer. Basically ‘const’ applies to whatever is on its immediate left (other than if there is nothing there in which case it applies to whatever is its immediate right).

Use of ‘const’ in Functions Return Values

Of the mixes of pointers and ‘const’, the constant pointer to a variable is useful for storage that can be changed in value but not moved in memory and the pointer (constant or otherwise) is useful for returning constant strings and arrays from functions which, because they are implemented as pointers, the program could otherwise try to alter and crash. Instead of a difficult to track down crash, the attempt to alter unalterable values will be detected during compilation.

For example, if a function which returns a fixed ‘Some text’ string is written like

char *Function1()
{ return “Some text”;}
then the program could crash if it accidentally tried to alter the value doing

Function1()[1]=’a’;
whereas the compiler would have spotted the error if the original function had been written

const char *Function1()
{ return "Some text";}
because the compiler would then know that the value was unalterable. (Of course, the compiler could theoretically have worked that out anyway but C is not that clever.)

Where it Gets Messy - in Parameter Passing

When a subroutine or function is called with parameters, variables passed as the parameters might be read from to transfer data into the subroutine/function, written to to transfer data back to the calling program or both to do both. Some languages enable one to specify this directly, such as having ‘in:’, ‘out:’ & ‘inout:’ parameter types, whereas in C one has to work at a lower level and specify the method for passing the variables choosing one that also allows the desired data transfer direction.

For example, a subroutine like

void Subroutine1(int Parameter1)
{ printf("%d",Parameter1);}
accepts the parameter passed to it in the default C & C++ way which is a copy. Therefore the subroutine can read the value of the variable passed to it but not alter it because any alterations it makes are only made to the copy and lost when the subroutine ends so

void Subroutine2(int Parameter1)
{ Parameter1=96;}
would leave the variable it was called with unchanged not set to 96.

The addition of an ‘&’ to the parameter name in C++ (which was a very confusing choice of symbol because an ‘&’ infront of variables elsewhere in C generate pointers!) like causes the actual variable itself, rather than a copy, to be used as the parameter in the subroutine and therefore can be written to thereby passing data back out the subroutine. Therefore

void Subroutine3(int &Parameter1) 
{ Parameter1=96;}
would set the variable it was called with to 96. This method of passing a variable as itself rather than a copy is called a ‘reference’ in C.

That way of passing variables was a C++ addition to C. To pass an alterable variable in original C, a rather involved method using a pointer to the variable as the parameter then altering what it pointed to was used. For example

void Subroutine4(int *Parameter1) 
{ *Parameter1=96;}
works but requires the every use of the variable in the called routine so altered and the calling routine altered to pass a pointer to the variable which is rather cumbersome.

But where does ‘const’ come into this? Well, there is a second common use for passing data by reference or pointer instead of copy. That is when copying a the variable would waste too much memory or take too long. This is particularly likely with large compound user-defined variable types (‘structures’ in C & ‘classes’ in C++). So a subroutine declared

void Subroutine4(big_structure_type &Parameter1);
might being using ‘&’ because it is going to alter the variable passed to it or it might just be to save copying time and there is no way to tell which it is if the function is compiled in someone else’s library. This could be a risk if one needs to trust the the subroutine not to alter the variable.

To solve this, ‘const’ can be used the in the parameter list like

void Subroutine4(big_structure_type const &Parameter1);
which will cause the variable to passed without copying but stop it from then being altered. This is messy because it is essentially making an in-only variable passing method from a both-ways variable passing method which was itself made from an in-only variable passing method just to trick the compiler into doing some optimization.

Ideally, the programmer should not need control this detail of specifying exactly how it variables are passed, just say which direction the information goes and leave the compiler to optimize it automatically, but C was designed for raw low-level programming on far less powerful computers than are standard these days so the programmer has to do it explicitly.

Messier Still - in the Object Oriented Programming

In Object Oriented Programming, calling a ‘method’ (the Object Oriented name for a function) of an object has gives an extra complication. As well as the variables in the parameter list, the method has access to the member variables of the object itself which are always passed directly not as copies. For example a trivial class, ‘Class1’, defined as

class Class1
{ void Method1();
  int MemberVariable1;}
has no explicit parameters at all to ‘Method1’ but calling it in an object in this class might alter ‘MemberVariable1’ of that object if ‘Method1’ happened to be, for example,

void Class1::Method1()
{ MemberVariable1=MemberVariable1+1;}
The solution to that is to put ‘const’ after the parameter list like

class Class2
{ void Method1() const;
  int MemberVariable1;}
which will ban Method1 in Class2 from being anything which can attempt to alter any member variables in the object.

Of course one sometimes needs to combine some of these different uses of ‘const’ which can get confusing as in

const int*const Method3(const int*const&)const;
where the 5 uses ‘const’ respectively mean that the variable pointed to by the returned pointer & the returned pointer itself won’t be alterable and that the method does not alter the variable pointed to by the given pointer, the given pointer itself & the object of which it is a method!.

Inconveniences of ‘const’

Besides the confusingness of the ‘const’ syntax, there are some useful things which the system prevents programs doing.

One in particular annoys me because my programs often need to be optimized for speed. This is that a method which is declared ‘const’ cannot even make changes to the hidden parts of its object that would not make any changes that would be apparent from the outside. This includes storing intermediary results of long calculations which would save processing time in subsequent calls to the class’s methods. Instead it either has to pass such intermediary results back to the calling routine to store and pass back next time (messy) or recalculate from scratch next time (inefficient). In later versions of C++, the ‘mutable’ keyword was added which enables ‘const’ to be overridden for this purpose but it totally relies on trusting the programmer to only use it for that purpose so, if you have to write a program using someone else's class which uses ‘mutable’ then you cannot guarantee that ‘‘mutable’ things will really be constant which renders ‘const’ virtually useless.

One cannot simply avoid using ‘const’ on class methods because ‘const’ is infectious. An object which has been made ‘const’, for example by being passed as a parameter in the ‘const &’ way, can only have those of its methods that are explicitly declared ‘const’ called (because C++’s calling system is too simple work out which methods not explicitly declared ‘const’ don’t actually change anything). Therefore class methods that don’t change the object are best declared ‘const’ so that they are not prevented from being called when an object of the class has somehow acquired ‘const’ status.

By Andrew Hardwick.
Distributable under GPL freeware licence. 
Written 2001.
Converted to HTML & augmented 2002/3/13.
Updated 2002/8/9, 2004/7/19, 2005/6/9 & 2006/5/22.
Spelling corrections 2008/3/4.
Available on-line at http://duramecho.com.The C++ 'const' Declaration: Why & How

The 'const' system is one of the really messy features of C++.

It is simple in concept, variables declared with ‘const’ added become constants and cannot be altered by the program, but, in the way is has to be used to bodge in a substitute for one of the missing features of C++, it gets horridly complicated and frustratingly restrictive. The following attempts to explain how 'const' is used and why it exists.

Simple Use of ‘const’

The simplest use is to declare a named constant. To do this, one declares a constant as if it was a variable but add ‘const’ before it. One has to initialise it immediately in the constructor because, of course, one cannot set the value later as that would be altering it. For example,

const int Constant1=96;
will create an integer constant, unimaginatively called ‘Constant1’, with the value 96.

Such constants are useful for parameters which are used in the program but are do not need to be changed after the program is compiled. It has an advantage for programmers over the C preprocessor ‘#define’ command in that it is understood & used by the compiler itself, not just substituted into the program text by the preprocessor before reaching the main compiler, so error messages are much more helpful.

It also works with pointers but one has to be careful where ‘const’ to determine whether the pointer or what it points to is constant or both. For example,

const int * Constant2
declares that Constant2 is variable pointer to a constant integer and

int const * Constant2
is an alternative syntax which does the same, whereas

int * const Constant3
declares that Constant3 is constant pointer to a variable integer and

int const * const Constant4
declares that Constant4 is constant pointer to a constant integer. Basically ‘const’ applies to whatever is on its immediate left (other than if there is nothing there in which case it applies to whatever is its immediate right).

Use of ‘const’ in Functions Return Values

Of the mixes of pointers and ‘const’, the constant pointer to a variable is useful for storage that can be changed in value but not moved in memory and the pointer (constant or otherwise) is useful for returning constant strings and arrays from functions which, because they are implemented as pointers, the program could otherwise try to alter and crash. Instead of a difficult to track down crash, the attempt to alter unalterable values will be detected during compilation.

For example, if a function which returns a fixed ‘Some text’ string is written like

char *Function1()
{ return “Some text”;}
then the program could crash if it accidentally tried to alter the value doing

Function1()[1]=’a’;
whereas the compiler would have spotted the error if the original function had been written

const char *Function1()
{ return "Some text";}
because the compiler would then know that the value was unalterable. (Of course, the compiler could theoretically have worked that out anyway but C is not that clever.)

Where it Gets Messy - in Parameter Passing

When a subroutine or function is called with parameters, variables passed as the parameters might be read from to transfer data into the subroutine/function, written to to transfer data back to the calling program or both to do both. Some languages enable one to specify this directly, such as having ‘in:’, ‘out:’ & ‘inout:’ parameter types, whereas in C one has to work at a lower level and specify the method for passing the variables choosing one that also allows the desired data transfer direction.

For example, a subroutine like

void Subroutine1(int Parameter1)
{ printf("%d",Parameter1);}
accepts the parameter passed to it in the default C & C++ way which is a copy. Therefore the subroutine can read the value of the variable passed to it but not alter it because any alterations it makes are only made to the copy and lost when the subroutine ends so

void Subroutine2(int Parameter1)
{ Parameter1=96;}
would leave the variable it was called with unchanged not set to 96.

The addition of an ‘&’ to the parameter name in C++ (which was a very confusing choice of symbol because an ‘&’ infront of variables elsewhere in C generate pointers!) like causes the actual variable itself, rather than a copy, to be used as the parameter in the subroutine and therefore can be written to thereby passing data back out the subroutine. Therefore

void Subroutine3(int &Parameter1) 
{ Parameter1=96;}
would set the variable it was called with to 96. This method of passing a variable as itself rather than a copy is called a ‘reference’ in C.

That way of passing variables was a C++ addition to C. To pass an alterable variable in original C, a rather involved method using a pointer to the variable as the parameter then altering what it pointed to was used. For example

void Subroutine4(int *Parameter1) 
{ *Parameter1=96;}
works but requires the every use of the variable in the called routine so altered and the calling routine altered to pass a pointer to the variable which is rather cumbersome.

But where does ‘const’ come into this? Well, there is a second common use for passing data by reference or pointer instead of copy. That is when copying a the variable would waste too much memory or take too long. This is particularly likely with large compound user-defined variable types (‘structures’ in C & ‘classes’ in C++). So a subroutine declared

void Subroutine4(big_structure_type &Parameter1);
might being using ‘&’ because it is going to alter the variable passed to it or it might just be to save copying time and there is no way to tell which it is if the function is compiled in someone else’s library. This could be a risk if one needs to trust the the subroutine not to alter the variable.

To solve this, ‘const’ can be used the in the parameter list like

void Subroutine4(big_structure_type const &Parameter1);
which will cause the variable to passed without copying but stop it from then being altered. This is messy because it is essentially making an in-only variable passing method from a both-ways variable passing method which was itself made from an in-only variable passing method just to trick the compiler into doing some optimization.

Ideally, the programmer should not need control this detail of specifying exactly how it variables are passed, just say which direction the information goes and leave the compiler to optimize it automatically, but C was designed for raw low-level programming on far less powerful computers than are standard these days so the programmer has to do it explicitly.

Messier Still - in the Object Oriented Programming

In Object Oriented Programming, calling a ‘method’ (the Object Oriented name for a function) of an object has gives an extra complication. As well as the variables in the parameter list, the method has access to the member variables of the object itself which are always passed directly not as copies. For example a trivial class, ‘Class1’, defined as

class Class1
{ void Method1();
  int MemberVariable1;}
has no explicit parameters at all to ‘Method1’ but calling it in an object in this class might alter ‘MemberVariable1’ of that object if ‘Method1’ happened to be, for example,

void Class1::Method1()
{ MemberVariable1=MemberVariable1+1;}
The solution to that is to put ‘const’ after the parameter list like

class Class2
{ void Method1() const;
  int MemberVariable1;}
which will ban Method1 in Class2 from being anything which can attempt to alter any member variables in the object.

Of course one sometimes needs to combine some of these different uses of ‘const’ which can get confusing as in

const int*const Method3(const int*const&)const;
where the 5 uses ‘const’ respectively mean that the variable pointed to by the returned pointer & the returned pointer itself won’t be alterable and that the method does not alter the variable pointed to by the given pointer, the given pointer itself & the object of which it is a method!.

Inconveniences of ‘const’

Besides the confusingness of the ‘const’ syntax, there are some useful things which the system prevents programs doing.

One in particular annoys me because my programs often need to be optimized for speed. This is that a method which is declared ‘const’ cannot even make changes to the hidden parts of its object that would not make any changes that would be apparent from the outside. This includes storing intermediary results of long calculations which would save processing time in subsequent calls to the class’s methods. Instead it either has to pass such intermediary results back to the calling routine to store and pass back next time (messy) or recalculate from scratch next time (inefficient). In later versions of C++, the ‘mutable’ keyword was added which enables ‘const’ to be overridden for this purpose but it totally relies on trusting the programmer to only use it for that purpose so, if you have to write a program using someone else's class which uses ‘mutable’ then you cannot guarantee that ‘‘mutable’ things will really be constant which renders ‘const’ virtually useless.

One cannot simply avoid using ‘const’ on class methods because ‘const’ is infectious. An object which has been made ‘const’, for example by being passed as a parameter in the ‘const &’ way, can only have those of its methods that are explicitly declared ‘const’ called (because C++’s calling system is too simple work out which methods not explicitly declared ‘const’ don’t actually change anything). Therefore class methods that don’t change the object are best declared ‘const’ so that they are not prevented from being called when an object of the class has somehow acquired ‘const’ status.

*** basics
**** const pointer and pointer to const
The C++ 'const' Declaration: Why & How

The 'const' system is one of the really messy features of C++.

It is simple in concept, variables declared with ‘const’ added become constants and cannot be altered by the program, but, in the way is has to be used to bodge in a substitute for one of the missing features of C++, it gets horridly complicated and frustratingly restrictive. The following attempts to explain how 'const' is used and why it exists.

Simple Use of ‘const’

The simplest use is to declare a named constant. To do this, one declares a constant as if it was a variable but add ‘const’ before it. One has to initialise it immediately in the constructor because, of course, one cannot set the value later as that would be altering it. For example,

const int Constant1=96;
will create an integer constant, unimaginatively called ‘Constant1’, with the value 96.

Such constants are useful for parameters which are used in the program but are do not need to be changed after the program is compiled. It has an advantage for programmers over the C preprocessor ‘#define’ command in that it is understood & used by the compiler itself, not just substituted into the program text by the preprocessor before reaching the main compiler, so error messages are much more helpful.

It also works with pointers but one has to be careful where ‘const’ to determine whether the pointer or what it points to is constant or both. For example,

const int * Constant2
declares that Constant2 is variable pointer to a constant integer and

int const * Constant2
is an alternative syntax which does the same, whereas

int * const Constant3
declares that Constant3 is constant pointer to a variable integer and

int const * const Constant4
declares that Constant4 is constant pointer to a constant integer. Basically ‘const’ applies to whatever is on its immediate left (other than if there is nothing there in which case it applies to whatever is its immediate right).

Use of ‘const’ in Functions Return Values

Of the mixes of pointers and ‘const’, the constant pointer to a variable is useful for storage that can be changed in value but not moved in memory and the pointer (constant or otherwise) is useful for returning constant strings and arrays from functions which, because they are implemented as pointers, the program could otherwise try to alter and crash. Instead of a difficult to track down crash, the attempt to alter unalterable values will be detected during compilation.

For example, if a function which returns a fixed ‘Some text’ string is written like

char *Function1()
{ return “Some text”;}
then the program could crash if it accidentally tried to alter the value doing

Function1()[1]=’a’;
whereas the compiler would have spotted the error if the original function had been written

const char *Function1()
{ return "Some text";}
because the compiler would then know that the value was unalterable. (Of course, the compiler could theoretically have worked that out anyway but C is not that clever.)

Where it Gets Messy - in Parameter Passing

When a subroutine or function is called with parameters, variables passed as the parameters might be read from to transfer data into the subroutine/function, written to to transfer data back to the calling program or both to do both. Some languages enable one to specify this directly, such as having ‘in:’, ‘out:’ & ‘inout:’ parameter types, whereas in C one has to work at a lower level and specify the method for passing the variables choosing one that also allows the desired data transfer direction.

For example, a subroutine like

void Subroutine1(int Parameter1)
{ printf("%d",Parameter1);}
accepts the parameter passed to it in the default C & C++ way which is a copy. Therefore the subroutine can read the value of the variable passed to it but not alter it because any alterations it makes are only made to the copy and lost when the subroutine ends so

void Subroutine2(int Parameter1)
{ Parameter1=96;}
would leave the variable it was called with unchanged not set to 96.

The addition of an ‘&’ to the parameter name in C++ (which was a very confusing choice of symbol because an ‘&’ infront of variables elsewhere in C generate pointers!) like causes the actual variable itself, rather than a copy, to be used as the parameter in the subroutine and therefore can be written to thereby passing data back out the subroutine. Therefore

void Subroutine3(int &Parameter1) 
{ Parameter1=96;}
would set the variable it was called with to 96. This method of passing a variable as itself rather than a copy is called a ‘reference’ in C.

That way of passing variables was a C++ addition to C. To pass an alterable variable in original C, a rather involved method using a pointer to the variable as the parameter then altering what it pointed to was used. For example

void Subroutine4(int *Parameter1) 
{ *Parameter1=96;}
works but requires the every use of the variable in the called routine so altered and the calling routine altered to pass a pointer to the variable which is rather cumbersome.

But where does ‘const’ come into this? Well, there is a second common use for passing data by reference or pointer instead of copy. That is when copying a the variable would waste too much memory or take too long. This is particularly likely with large compound user-defined variable types (‘structures’ in C & ‘classes’ in C++). So a subroutine declared

void Subroutine4(big_structure_type &Parameter1);
might being using ‘&’ because it is going to alter the variable passed to it or it might just be to save copying time and there is no way to tell which it is if the function is compiled in someone else’s library. This could be a risk if one needs to trust the the subroutine not to alter the variable.

To solve this, ‘const’ can be used the in the parameter list like

void Subroutine4(big_structure_type const &Parameter1);
which will cause the variable to passed without copying but stop it from then being altered. This is messy because it is essentially making an in-only variable passing method from a both-ways variable passing method which was itself made from an in-only variable passing method just to trick the compiler into doing some optimization.

Ideally, the programmer should not need control this detail of specifying exactly how it variables are passed, just say which direction the information goes and leave the compiler to optimize it automatically, but C was designed for raw low-level programming on far less powerful computers than are standard these days so the programmer has to do it explicitly.

Messier Still - in the Object Oriented Programming

In Object Oriented Programming, calling a ‘method’ (the Object Oriented name for a function) of an object has gives an extra complication. As well as the variables in the parameter list, the method has access to the member variables of the object itself which are always passed directly not as copies. For example a trivial class, ‘Class1’, defined as

class Class1
{ void Method1();
  int MemberVariable1;}
has no explicit parameters at all to ‘Method1’ but calling it in an object in this class might alter ‘MemberVariable1’ of that object if ‘Method1’ happened to be, for example,

void Class1::Method1()
{ MemberVariable1=MemberVariable1+1;}
The solution to that is to put ‘const’ after the parameter list like

class Class2
{ void Method1() const;
  int MemberVariable1;}
which will ban Method1 in Class2 from being anything which can attempt to alter any member variables in the object.

Of course one sometimes needs to combine some of these different uses of ‘const’ which can get confusing as in

const int*const Method3(const int*const&)const;
where the 5 uses ‘const’ respectively mean that the variable pointed to by the returned pointer & the returned pointer itself won’t be alterable and that the method does not alter the variable pointed to by the given pointer, the given pointer itself & the object of which it is a method!.

Inconveniences of ‘const’

Besides the confusingness of the ‘const’ syntax, there are some useful things which the system prevents programs doing.

One in particular annoys me because my programs often need to be optimized for speed. This is that a method which is declared ‘const’ cannot even make changes to the hidden parts of its object that would not make any changes that would be apparent from the outside. This includes storing intermediary results of long calculations which would save processing time in subsequent calls to the class’s methods. Instead it either has to pass such intermediary results back to the calling routine to store and pass back next time (messy) or recalculate from scratch next time (inefficient). In later versions of C++, the ‘mutable’ keyword was added which enables ‘const’ to be overridden for this purpose but it totally relies on trusting the programmer to only use it for that purpose so, if you have to write a program using someone else's class which uses ‘mutable’ then you cannot guarantee that ‘‘mutable’ things will really be constant which renders ‘const’ virtually useless.

One cannot simply avoid using ‘const’ on class methods because ‘const’ is infectious. An object which has been made ‘const’, for example by being passed as a parameter in the ‘const &’ way, can only have those of its methods that are explicitly declared ‘const’ called (because C++’s calling system is too simple work out which methods not explicitly declared ‘const’ don’t actually change anything). Therefore class methods that don’t change the object are best declared ‘const’ so that they are not prevented from being called when an object of the class has somehow acquired ‘const’ status.

**** 左右法则 -- 如何理解c和c ++的复杂类型声明
曾经碰到过让你迷惑不解、类似于int * (* (*fp1) (int) ) [10];这样的变量声明吗？本文将由易到难，一步一步教会你如何理解这种复杂的C/C++声明。 

我们将从每天都能碰到的较简单的声明入手，然后逐步加入const修饰符和typedef，还有函数指针，最后介绍一个能够让你准确地理解任何C/C++声明的“右左法则”。 

需要强调一下的是，复杂的C/C++声明并不是好的编程风格；我这里仅仅是教你如何去理解这些声明。注意：为了保证能够在同一行上显示代码和相关注释，本文最好在至少1024x768分辨率的显示器上阅读。 
让我们从一个非常简单的例子开始，如下：
 int n;

这个应该被理解为“declare n as an int”（n是一个int型的变量）。接下去来看一下指针变量，如下： 
 int *p;
这个应该被理解为“declare p as an int *”（p是一个int *型的变量），或者说p是一个指向一个int型变量的指针。我想在这里展开讨论一下：我觉得在声明一个指针（或引用）类型的变量时，最好将*（或&）写在紧靠变量之前，而不是紧跟基本类型之后。这样可以避免一些理解上的误区，比如： 
再来看一个指针的指针的例子： 

 char **argv;

理论上，对于指针的级数没有限制，你可以定义一个浮点类型变量的指针的指针的指针的指针，再来看如下的声明： 

 int RollNum[30][4]; 
int (*p)[4]=RollNum; 
int *q[5];
这里，p被声明为一个指向一个4元素（int类型）数组的指针，而q被声明为一个包含5个元素（int类型的指针）的数组。另外，我们还可以在同一个声明中混合实用*和&，如下： 

 int **p1; 
// p1 is a pointer  to a pointer  to an int. 
int *&p2; 
// p2 is a reference to a pointer  to an int. 
int &*p3; 
// ERROR: Pointer  to a reference is illegal. 
int &&p4;
// ERROR: Reference to a reference is illegal.


注：p1是一个int类型的指针的指针；p2是一个int类型的指针的引用；p3是一个int类型引用的指针（不合法！）；p4是一个int类型引用的引用（不合法！）。 

const修饰符 

当你想阻止一个变量被改变，可能会用到const关键字。在你给一个变量加上const修饰符的同时，通常需要对它进行初始化，因为以后的任何时候你将没有机会再去改变它。例如： 

 const int n=5; 
int const m=10;


上述两个变量n和m其实是同一种类型的——都是const int（整形恒量）。因为C++标准规定，const关键字放在类型或变量名之前等价的。我个人更喜欢第一种声明方式，因为它更突出了const修饰符的作用。当const与指针一起使用时，容易让人感到迷惑。例如，我们来看一下下面的p和q的声明： 

 const int *p; 
int const *q;


他们当中哪一个代表const int类型的指针（const直接修饰int），哪一个代表int类型的const指针（const直接修饰指针）？实际上，p和q都被声明为const int类型的指针。而int类型的const指针应该这样声明： 


 int * const r= &n;
// n has been declared as an int


这里，p和q都是指向const int类型的指针，也就是说，你在以后的程序里不能改变*p的值。而r是一个const指针，它在声明的时候被初始化指向变量n（即r=&n;）之后，r的值将不再允许被改变（但*r的值可以改变）。 

组合上述两种const修饰的情况，我们来声明一个指向const int类型的const指针，如下： 

 const int * const p=&n 
// n has been declared as const int


下面给出的一些关于const的声明，将帮助你彻底理清const的用法。不过请注意，下面的一些声明是不能被编译通过的，因为他们需要在声明的同时进行初始化。为了简洁起见，我忽略了初始化部分；因为加入初始化代码的话，下面每个声明都将增加两行代码。 

 char ** p1; 
//    pointer to    pointer to    char 
const char **p2;
//    pointer to    pointer to const char 
char * const * p3;
//    pointer to const pointer to    char 
const char * const * p4;
//    pointer to const pointer to const char 
char ** const p5;
// const pointer to    pointer to    char 
const char ** const p6;
// const pointer to    pointer to const char 
char * const * const p7;
// const pointer to const pointer to    char 
const char * const * const p8;
// const pointer to const pointer to const char


注：p1是指向char类型的指针的指针；p2是指向const char类型的指针的指针；p3是指向char类型的const指针；p4是指向const char类型的const指针；p5是指向char类型的指针的const指针；p6是指向const char类型的指针的const指针；p7是指向char类型const指针的const指针；p8是指向const char类型的const指针的const指针。 

typedef的妙用 

typedef给你一种方式来克服“*只适合于变量而不适合于类型”的弊端。你可以如下使用typedef： 

 typedef char * PCHAR; 
PCHAR p,q;


这里的p和q都被声明为指针。（如果不使用typedef，q将被声明为一个char变量，这跟我们的第一眼感觉不太一致！）下面有一些使用typedef的声明，并且给出了解释： 

 typedef char * a;
// a is a pointer to a char 

typedef a b();
// b is a function that returns 
// a pointer to a char 

typedef b *c;
// c is a pointer to a function 
// that returns a pointer to a char 

typedef c d();
// d is a function returning 
// a pointer to a function 
// that returns a pointer to a char 

typedef d *e;
// e is a pointer to a function 
// returning a pointer to a 
// function that returns a 
// pointer to a char 

e var[10];
// var is an array of 10 pointers to 
// functions returning pointers to 
// functions returning pointers to chars.


typedef经常用在一个结构声明之前，如下。这样，当创建结构变量的时候，允许你不使用关键字struct（在C中，创建结构变量时要求使用struct关键字，如struct tagPOINT a；而在C++中，struct可以忽略，如tagPOINT b）。 

 typedef struct tagPOINT 
{ 
  int x; 
  int y; 
}POINT; 

POINT p; /* Valid C code */
函数指针

函数指针可能是最容易引起理解上的困惑的声明。函数指针在DOS时代写TSR程序时用得最多；在Win32和X-Windows时代，他们被用在需要回调函数的场合。当然，还有其它很多地方需要用到函数指针：虚函数表，STL中的一些模板，Win NT/2K/XP系统服务等。让我们来看一个函数指针的简单例子：





 int (*p)(char);


这里p被声明为一个函数指针，这个函数带一个char类型的参数，并且有一个int类型的返回值。另外，带有两个float类型参数、返回值是char类型的指针的指针的函数指针可以声明如下： 

 char ** (*p)(float, float);


那么，带两个char类型的const指针参数、无返回值的函数指针又该如何声明呢？参考如下： 

 void * (*a[5])(char * const, char * const);


“右左法则”是一个简单的法则，但能让你准确理解所有的声明。这个法则运用如下：从最内部的括号开始阅读声明，向右看，然后向左看。当你碰到一个括号时就调转阅读的方向。括号内的所有内容都分析完毕就跳出括号的范围。这样继续，直到整个声明都被分析完毕。 

对上述“右左法则”做一个小小的修正：当你第一次开始阅读声明的时候，你必须从变量名开始，而不是从最内部的括号。 

下面结合例子来演示一下“右左法则”的使用。 

 int * (* (*fp1) (int) ) [10];


阅读步骤： 

1. 从变量名开始——fp1 

2. 往右看，什么也没有，碰到了)，因此往左看，碰到一个*——一个指针 

3. 跳出括号，碰到了(int)——一个带一个int参数的函数 

4. 向左看，发现一个*——（函数）返回一个指针 

5. 跳出括号，向右看，碰到[10]——一个10元素的数组 

6. 向左看，发现一个*——指针 

7. 向左看，发现int——int类型 

总结：fp1被声明成为一个函数的指针,该函数返回指向指针数组的指针. 

再来看一个例子： 

 int *( *( *arr[5])())();


阅读步骤： 

1. 从变量名开始——arr 

2. 往右看，发现是一个数组——一个5元素的数组 

3. 向左看，发现一个*——指针 

4. 跳出括号，向右看，发现()——不带参数的函数 

5. 向左看，碰到*——（函数）返回一个指针 

6. 跳出括号，向右发现()——不带参数的函数 

7. 向左，发现*——（函数）返回一个指针 

8. 继续向左，发现int——int类型 

还有更多的例子： 

 float ( * ( *b()) [] )();
// b is a function that returns a 
// pointer to an array of pointers 
// to functions returning floats. 
void * ( *c) ( char, int (*)());
// c is a pointer to a function that takes 
// two parameters: 
// a char and a pointer to a 
// function that takes no 
// parameters and returns 
// an int 
// and returns a pointer to void. 
void ** (*d) (int &, 
char **(*)(char *, char **));
// d is a pointer to a function that takes 
// two parameters: 
// a reference to an int and a pointer 
// to a function that takes two parameters: 
// a pointer to a char and a pointer 
// to a pointer to a char 
// and returns a pointer to a pointer 
// to a char 
// and returns a pointer to a pointer to void 
float ( * ( * e[10]) 
  (int &) ) [5];
// e is an array of 10 pointers to 
// functions that take a single 
// reference to an int as an argument 
// and return pointers to 
// an array of 5 floats.
**** tagname and typedef names
all struct/union/enum/class declarations act like they are implicitly typedef'ed, as long as the name is not hidden by another declaration with the same name
http://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c
That means in C++, when you say
#+begin_src c++
struct Foo { ... };
#+end_src
you don't have to declare object as
#+begin_src c++
struct Foo ob;
#+end_src
all the time (in contrast to pure C). You could just say:
#+begin_src c++
Foo ob;
#+end_src

**** number(integer, float etc) to string
***** method (require c++11)
C++0x introduces std::stoi (and variants for each numeric type) and std::to_string, the counterparts of the C atoi and itoa but expressed in term of std::string
#+begin_src c++
  std::string s = std::to_string(42);
#+end_src
***** method by using ostringstream
#+begin_src c++
  #include <sstream>
  #define SSTR( x ) dynamic_cast< std::ostringstream & >( \
          ( std::ostringstream() << std::dec << x ) ).str()
  // to use
  int x = 42;
  cout << SSTR( "i is: " << x );
  string s = SSTR( i );
  puts( SSTR( i ).c_str() );
#+end_src
or
#+begin_src c++
  #include <sstream>
  template <typename T>
    string NumberToString ( T Number )
    {
       ostringstream ss;
       ss << Number;
       return ss.str();
    }
#+end_src
Here the number can be any type: integer, float etc.
***** method by using lexical_cast from Boost
#+begin_src c++
#include <boost/lexical_cast.hpp>
int num = 4;
std::string str = boost::lexical_cast<std::string>(num);
#+end_src 
*** namespace
#+begin_src c++
// both
using namespace std
// and
using std:cin
#+end_src
allows you to use "cin" instead of "std::cin"

*** How to dynamically initiate a matrix / 2-d array?
    int **matrix;
    matrix = new int* [num_rows]
    for (int i = 0; i < num_rows; i++)
    *(matrix+i) = new int[num_columns];
    # to use, just type matrix[i][j]
    # or use vector<vector< > >
    vector<vector<double> > matrix;
    matrix.resize(num_rows);
    for(int i = 0; i < num_rows; i++)
    matrix[i].resize(num_columns)

*** STL
**** how to reverse a string?
#+begin_src c++
#include <algorithm>
std::reverse(str.begin(), str.end());
#+end_src
*** struct vs class in C++
从语法上，在C++中（只讨论C++中）。class和struct做类型定义时只有两点区别：

　　（一）默认继承权限。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理；

　　（二）成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。

　　除了这两点，class和struct基本就是一个东西。语法上没有任何其它区别。

　　不能因为学过C就总觉得连C++中struct和class都区别很大，下面列举的说明可能比较无聊，因为struct和class本来就是基本一样的东西，无需多说。但这些说明可能有助于澄清一些常见的关于struct和class的错误认识：

　　（1）都可以有成员函数；包括各类构造函数，析构函数，重载的运算符，友元类，友元结构，友元函数，虚函数，纯虚函数，静态函数；

　　（2）都可以有一大堆public/private/protected修饰符在里边；

　　（3）虽然这种风格不再被提倡，但语法上二者都可以使用大括号的方式初始化：A a = {1, 2, 3};不管A是个struct还是个class，前提是这个类/结构足够简单，比如所有的成员都是public的，所有的成员都是简单类型，没有显式声明的构造函数。

　　（4）都可以进行复杂的继承甚至多重继承，一个struct可以继承自一个class，反之亦可；一个struct可以同时继承5个class和5个struct，虽然这样做不太好。

　　（5）如果说class的设计需要注意OO的原则和风格，那么没任何理由说设计struct就不需要注意。

　　（6）再次说明，以上所有说法都是指在C++语言中，至于在C里的情况，C里是根本没有“class”，而C的struct从根本上也只是个包装数据的语法机制。

　　---------------------------------------------------------------

　　最后，作为语言的两个关键字，除去定义类型时有上述区别之外，另外还有一点点：“class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数。

　　如果没有多态和虚拟继承，在C++中，struct和class的存取效率完全相同！简单的说就是，存取class的data member和非virtual function效率和struct完全相同！不管该data member是定义在基类还是派生类的。

　　如果不是为了和C兼容，C++中就不会有struct关键字。因此建议是：如果不需要与C兼容或传递参数给C程序，不要在C++中用struct。

　　注意class的data member在内存中的布局可不一定是data member的申明次序。C++只保证处于同一个access section的data member按照申明次序排列。

　　struct所体现的是一种数据结构，而class则是体现OOP思想中的"封装"的特性~~~

　　还有一个区别：struct可以用{}赋初值，而class不行

　　比如声明如下：

　　struct abc{ int m1; float m2; bool m3; }

　　可以这么构造对象：

　　abc abcInstance{ 1, 1.0f, false };

　　struct：属性

　　class：属性+行为

　　注意：在VC6里，class可以与模板关键字typename互换，但是struct好像就不可以，编译好像通不过。对这个问题，我专门查了一些资料，发现网上确实有说 struct不能用于模板关键字而class可以，这似乎应该是他们的一个不同了。然而，我又看了一下 《深度探索C++对象模型》，在书的前几章（好像就是第一章）Lippman说：本来他的编译器是不支持将struct作为模板关键字的，但后来改变了，也就是说struct 和class除了默认的访问属性外，其他场合下真正的完全一样了。对此，我认为这个按理说是这样的，但不同的编译器可能会有自己的处理，就像VC6那样。

　　class中有方法,

　　struct中没有.

　　class是一个扩展的struct

　　array(类型一样)->struct(类型可以不一致)->class(添加方法)

　　虽然两者都可以捆绑行为。

　　但是，理解不一样。

　　struct，就是对程序员全局可见的数据与方法。简化数据逻辑结构的设计。可以说是一种自定义的数据结构。

　　而class，则是将数据与方法封装，即让行为与数据一致。则是一种编程方法。即客观世界在代码世界中的体现。体现的是一种编程思想。

　　在C里面：struct不能包含函数，而class可以。

　　在C++里面：都可以有函数，默认情况下struct中变量是public,而class中是private

　　有一点不明白,class支持的继承和多态,struct也支持??

　　class在赋值运算符右边出现需要有定义的拷贝构造函数,而struct是默认的位拷贝.

　　但是一般从兼容C的角度考虑，struct里面只包含数据成员而不包含成员函数，这只是一个编程习惯问题。

*** STL and C++ standard library
neither is a strict superset of the other.
For example, <hash_map> is in STL but not in C++ standard library
<map> is shared between STL and C++ standard library
*** qt
**** signal-slot
***** connect
      connect(sender, SIGNAL(signal), receiver, SLOT(slot));
      both sender and receiver are of QObject.
      signal and slot are function name.
      SIGNAL() and SLOT() are macros used for transforming arguments into strings.
****** one signal can be connected to multiple slots
       connect(slider, SIGNAL(valueChanged(int)),
       spinBox, SLOT(setValue(int)));
       connect(slider, SIGNAL(valueChanged(int)),
       this, SLOT(updateStatusBarIndicator(int)));
       // But notice that the order of being called is undetermined.
       // It is not necessarily the order the codes that appear.
****** multiple signals can be connected to one slot
       connect(lcd, SIGNAL(overflow()), this, SLOT(handleMathError()));
       connect(calculator, SIGNAL(divisionByZero()), this, SLOT(handleMathError()));
****** a signal can be connected to another signal
       connect(lineEdit, SIGNAL(textChanged(const QString &amp;)),
       this, SIGNAL(updateRecord(const QString &amp;)));
****** a signal can be disconnected
       disconnect(lcd, SIGNAL(overflow()), this, SLOT(handleMathError()));
***** 当一个对象 delete 之后,Qt 自动取消所有连接到这个对象上面的槽。
***** 为了正确的连接信号槽,信号和槽的参数个数、类型以及出现的顺序都必须相同.
      connect(ftp, SIGNAL(rawCommandReply(int, const QString& amp;)),
      this, SLOT(processReply(int, const QString& amp;)));  
      有一种例外情况,如果信号的参数多于槽的参数,那么这个参数之后的那些参数都会被忽略掉
**** compile
    1. create .pro file
       qmake -project
       the name of the .pro file follows the name of the current working directory
    2. create Makefile
       qmake -unix -o Makefile mycode.pro (or in short "qmake", which will look for the .pro file in the current directory.)
       Or, qmake -tp vc helloworld.pro (this generate nmake file)
    3. make
       make
**** QPainter
***** void QPainter::drawEllipse (const QRectF & rectangle )
      Draws the ellipse defined by the given rectangle.
****** example
       QRectF rectangle(10.0, 20.0, 80.0, 60,0);
       QPainter painter(this);
       painter.drawEllipse(rectangle)
***** void QPainter::drawEllipse (int x, int y, int width, int height)
      Draws the ellipse defined by the rectangle beginning at (x, y) with the given width and height.
***** void QPainter::drawEllipse (const QPointF &center, qreal rx, qreal ry)
      Draws the ellipse positioned at center with radii rx and ry.
***** void QPainter::drawEllipse (const QPoint &center, int rx, int ry)
      Draws the ellipse positioned at center with radii rx and ry.
**** QRectF
     rectangle using float precision
**** QRect
     rectangle using integer precision
**** QVariant
***** int QVariant::toInt ( bool * ok = 0 ) const
      Returns the variant as an int if the variant has type() Int, Bool, ByteArray, Char, Double, LongLong, String, UInt, or ULongLong; otherwise returns 0.
**** QWidget
***** QComboBox
****** QVariant QComboBox::itemData(int index, int role = Qt::UserRole) const
       Returns the data for the given role in the given index in the combobox
**** layout
     setLayout(someLayout);
***** QHBoxLayout
***** QVBoxLayout
***** QGridLayout
****** void QGridLayout::addWidget(QWidget * widget, int row, int column, Qt::Alignment alignment = 0)
       add the given widget to the cell grid at row, column. (0,0) is by default.
       alignment = 0 means the widget fills the entire cell.
****** void QGridLayout::addWidget(QWidget * widget, int fromRow, int fromColumn,int rowSpan, int columnSpan, Qt::Alignment alignment = 0)
       add the given widget to the cell grid, spanning multiple rows/column. The cell will start at (fromRow, fromColumn) spanning rowSpan rows and columnSpan columns.
       if rowSpan/columnSpan is -1, then the widget will extend to the bottom/right edge.
****** void QGridLayout::setColumnStretch (int column, int stretch)
       the stretch factor is relative to the other columns in this grid.
       Columns with a higher stretch factor take more of the available space.
       default stretch factor is 0. if 0, then no other column in this table can grow at all, the column may still grow.
******* example
       	mainLayout->setColumnStretch(0, 1);
****** void QGridLayout::setRowMinimumHeight(int row, int minSize)
       set the minimum height of row row to minSize pixels
******* example
       	mainLayout->setRowMinimumHeight(8, 6);
*** boost
**** boost/graph
***** boost/graph/adjacency_list.hpp
****** add_edge(int node1, int node2, g)
****** [template] adjacency_list
******* edge iterator constructor
       	adjacency_list(
       	EdgeIterator first, 
       	EdgeIterator last, 
       	EdgePropertyIterator ep_iter,
       	vertices_size_type n,
       	edges_size_type m = 0,
       	const GraphProperty& p = GraphProperty()
       	)
***** boost/graph/graph_traits.hpp
****** [template] graph_traits
**** boost/property_map
***** boost/property_map/property_map.hpp
****** get(p,g)
       return the property map for the property specified by the PropertyTag type p.
       return boost::property_map<G, PropertyTag>::type is g is mutable.
       return boost::property_map<G, PropertyTag>::const_type if g is not mutable.
****** get(p,g,x)
       return the property value associated with object x (a vertex or edge). 
       equivalent to get(get(p,g), x)
       return type: boost::property_traits<Map>::value_type
       where Map is boost::property_map<G,Property>::const_type
****** put(p,g,x,v)
       set the property (specified by the PropertyTag type) associated with object x (a vertex or an edge) to the value v.
       equivalent to: put(get(p,g), x,v)
**** boost/tuple/tuple.hpp
***** tie
**** boost/algorithm/string
***** split
**** boost/foreach.hpp
**** boost/tokenizer.hpp
     BOOST_FOREACH
     #define foreach BOOST_FOREACH
**** boost/utility.hpp
***** next(p) 不用改变iterator p，而访问p的下一个或前一个变量。
      因为p++会改变p。
****** usage
       const std::list<T>::iterator p = get_some_iterator();
       const std::list<T>::iterator prev = boost::prior(p);
       const std::list<T>::iterator next = boost::next(prev, 2);
*** cmake
**** what is in-source build
     cd Hello
     ccmake . ## this will look for the CMakeLists.txt 
     ## or one might explicitly specify that.
     make
**** what is out-of-source build
     mkdir HelloBuild
     cd HelloBuild
     ccmake ../Hello
     make
     Note: Before performing an out-of-source build ensure that any possible CMake generated in-source build information is removed from the source directory, e.g., CMakeFiles directory, and CMakeCache.txt.
     An in-source build CMakeCache.txt file can make an out-of-source build ineffective.
**** why the build tree CANNOT be copied or moved
     since CMake use absolute path.
**** cmake -DCMAKE_BUILD_TYPE=Debug ## debug build
**** cmake -DCMAKE_BUILD_TYPE=Release ## release build
**** commands
***** add_executable
      Add an executable to the project using the specified source files.
      add_executable(<name> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source2 ... sourceN)
***** add_subdirectory
***** add_library
      add_library(pcre ${PCRE_HEADERS} ${PCRE_SOURCES})
      add_library(pcreposix ${PCREPOSIX_HEADERS} ${PCREPOSIX_SOURCES})
      target_link_libraries(pcreposix pcre)
***** add_definitions
      Adds -D define flags to the compilation of source files.
      add_definitions(-DFOO -DBAR ...)
      will result in gcc -D FOO
      Adds flags to the compiler command line for sources in the current directory and below. 
***** checkincludefile
***** execute_process
***** message
      message(STATUS "The build type is ${CMAKE_BUILD_TYPE}")
      message(WARNING "")
      message(AUTHOR_WARNING "")
***** file
****** file(GLOB variable [RELATIVE path] [globbing expressions]...)
       GLOB will generate a list of all files that match the globbing expressions and store it into the variable.
***** get_target_property
      get_target_property(DFTABLE_EXE dftables LOCATION)
      LOCATION is a property
      DFTABLE is a variable to store the property information
      dftable is the target.
***** string
****** string(REGEX MATCH <regular_expression> <output variable> <input> [<input>...])
****** string(REGEX REPLACE <regular_expression> <replace_expression> <output variable> <input> [<input>...])
       REGEX REPLACE will match the regular expression as many times as possible and substitute the replacement expression for the match in the output. The replace expression may refer to paren-delimited subexpressions of the match using \1, \2, ..., \9.
***** include
      read CMakeList file code from another file.
      If a module is specified instead of a file, the file with name <modulename>.cmake is searched in the CMAKE_MODULE_PATH.
***** option
      set a boolean value
      option(<option_variable> "help string describing option" [initial value])
***** configure_file
     configure_file(<input> <output> [COPYONLY] [ESCAPE_QUOTES] [@ONLY])
     Copies a file <input> to file <output> and substitutes variable values referenced in the file content.
     If <input> is a relative path it is evaluated with respect to the current source directory. The <input> must be a file, not a directory. If <output> is a relative path it is evaluated with respect to the current binary directory.
     This command replaces any variables in the input file referenced as ${VAR} or @VAR@ with their values as determined by CMake. If a variable is not defined, it will be replaced with nothing.
     e.g.:
     configure_file(
     "${CMAKE_MODULE_PATH}/cmake_uninstall.cmake.in"
     "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
     IMMEDIATE @ONLY)
***** install
      install(TARGETS targets... [EXPORT <export-name>]
      [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE|
      PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]
      [DESTINATION <dir>]
      [PERMISSIONS permissions...]
      [CONFIGURATIONS [Debug|Release|...]]
      [COMPONENT <component>]
      [OPTIONAL] [NAMELINK_ONLY|NAMELINK_SKIP]
      ] [...])
***** link_directories
      link_directories(directory1 directory2 ...)
      Specify directories in which the linker will look for libraries.
      Specify the paths in which the linker should search for libraries. The command will apply only to targets created after it is called.
***** list
***** target_link_libraries
      target_link_libraries: Link a target to given libraries.
      target_link_libraries(<target> [item1 [item2 [...]]]
      [[debug|optimized|general] <item>] ...)
****** list(REMOVE_ITEM <list> <value> [<value> ...])
***** get_directory_property
      Get a property of DIRECTORY scope.
      get_directory_property(<variable> [DIRECTORY <dir>] <prop-name>)
      Store a property of directory scope in the named variable.
      The properties include: 
      INCLUDE_DIRECTORIES, 
      LINK_DIRECTORIES, 
      INCLUDE_REGULAR_EXPRESSION, 
      and ADDITIONAL_MAKE_CLEAN_FILES.
      ADDITIONAL_MAKE_CLEAN_FILES is a list of files that will be cleaned as a part of "make clean" stage.
***** set_directory_properties
      Set a property of the directory.
      set_directory_properties(PROPERTIES prop1 value1 prop2 value2)
      Set a property for the current directory and subdirectories.
***** set
      set(PCRECPP_HEADERS pcrecpp.h pcre_scanner.h ${CMAKE_BINARY_DIR}/pcrecpparg.h
      ${CMAKE_BINARY_DIR/pcre_stringpiece.h} )
      set(PCRECPP_SOURCES pcrecpp.cc pcre_scanner.cc pcre_stringpiece.cc)
**** target properties
***** MACOSX_BUNDLE
      Build an executable as an application bundle on Mac OS X.
***** WIN32_EXECUTABLE
      Build an executable with a WinMain entry point on windows.
      When this property is set to true the executable when linked on Windows will be created with a WinMain() entry point instead of of just main().This makes it a GUI executable instead of a console application.
**** standard CMake Modules
***** CheckCXXCompilerFlag
      Check whether the CXX compiler supports a given flag
***** CMakeForceCompiler
      CMAKE_FORCE_C_COMPILER
      CMAKE_CXX_COMPILER
      INCLUDE (CMakeForceCompiler)
***** findqt4
****** macro QT4_AUTOMOC(sourcefile1 sourcefile2 ... )
       This macro is still experimental.
       It can be used to have moc automatically handled.
****** macro QT_LIBRARIES
**** variables that describe the system
***** UNIX
      Set to true when the target system is UNIX or UNIX like (i.e. APPLE and CYGWIN).
***** WIN32
      Set to true when the target system is Windows and on cygwin.
**** CMAKE_SYSTEM_NAME
     Linux, Windows, Darwin for MacOSX etc.
**** compatibility commands
***** exec_program
      same as execute_process
**** example
***** 06-01-2010
      string(REPLACE "main.cpp" "" CXX_NO_MAIN "${CXX_FILES}")
      MESSAGE("\n\n moc files: ${MOC_FILES}\n\n")
      string(REPLACE "(*.cpp
      file(GLOB H_FILES "*.h")
      QT4_WRAP_CPP(MOC_FILES ${CXX_QOB_HEADERS})
      MESSAGE("\n\n moc files: ${MOC_FILES}\n\n")
      
      string(REPLACE "__/" "" MOC_FILES "${MOC_FILES}")
      MESSAGE("\n\n moc files: ${MOC_FILES}\n\n")
      FOREACH(MOC_FILE ${MOC_FILES})
      ADD_CUSTOM_COMMAND(
      OUTPUT $(CMAKE_CURRENT_BINARY_DIR)/MOC
      ADD_CUSTOM_TARGET(MOC_FILE DEPENDS $
      ENDFOREACH(MOC_FILE ${MOC_FILES})
      
      FOREACH(MOC_FILE ${MOC_FILES})
      add_dependencies(MOC_FILE MolAligner)
      ENDFOREACH(MOC_FILE ${MOC_FILES})
*** include的原则
    在.h里面尽量使用forward declaration
    在.cpp里，多include各种user header
*** gcc编译选项：
**** -Dname / -D name / -D name = definition
     定义宏，相当于 #define name 1
**** -fomit-frame-pointer
     忽略栈帧指针，在程序中不需要保存，安装，和恢复ebp
**** -O3 3rd level optimization.
**** -Wl,option 向linker传送option
     -Wl,-Map=output.map 传送自变量: -Map=output.map
     -Wl,-z,relro
**** -W warning
***** -Wall 启用所有warning.
***** -Wchar-subscripts
      warn if an array subscript has type "char"
*** g++编译选项
**** -W warning
***** -Wnon-virtual-dtor
      Warn when a class has virtual functions and accessible non-virtual destructor, in which case it would be possible but unsafe to delete an instance of a derived class through a pointer to the base class.
***** -Wlong-long / -Wno-long-long
      default
      warn if long long type is used.
      To disable, use -Wno-long-long
***** -Wcast-align

**** -ansi
*** function pointer
**** to declare
     a function pointer called my_func_ptr that points to a function taking an int and a char * and returning a float, is declared like this:
     float (*my_func_ptr)(int, char *)
**** to declare with typedef
     typedef float (*MyFuncPtrType)(int, char *)
     MyFuncPtrType my_func_ptr;
**** to point
     float some_func(int, char*);
     my_func_ptr = &some_func
     // You are allowed to ommit the "&" operator on most compilers
     // but it's not recommended.
**** to call
     (*my_func_ptr)(7, "Arbitrary String")
**** the use of function pointers
     In C, the most common uses of function pointers are as parameters to library functions like qsort, and as callbacks for Windows functions, etc. 
**** The compiler implementation of function pointers
     They are just "code pointers": they hold the starting address of an assembly-language routine. The different types of function pointers exist only to ensure that the correct calling convention is used.
**** restriction
     You are allowed to cast from one type of function pointer to another. But you are not allowed to cast a function pointer to a void * data pointer. 
     A function pointer can be set to 0 to mark it as a null pointer. 
     The full range of comparison operators are available (==, !=, <, >, <=, >=), and you can also test for null pointers using ==0 or via an implicit cast to bool. 
     A function pointer can be used as a non-type template parameter. This is fundamentally different from a type parameter, and is also different from an integral non-type parameter. It is instantiated based on name rather than type or value. Name-based template parameters are not supported by all compilers, not even by all those with support for partial template specialization.
*** member function pointer
    You are not allowed to use an ordinary function pointer to point to a member function; instead, you have to use a member function pointer. 
**** to declare
     float(SomeClass::*my_memfunc_ptr)(int, char*);
     float(SomeClass::*my_const_memfunc_ptr)(int,char*) const;

     Notice that a special operator (::*) is used
**** to point
***** ordinary member function
      my_memfunc_ptr = &SomeClass::some_member_func;
***** operators
      my_memfunc_ptr = &SomeClass::operator !;
***** cannot take the address of a constructor or destructor
**** to call
***** on heap (->*)
      SomeClass *x = new SomeClass;
      (x->*my_memfunc_ptr)(6, "Another Arbitrary Parameter");
***** on stack (.*)
      SomeClass y;
      (y.*my_memfunc_ptr)(15, "Different parameters this time");
**** operators
     A member function pointer can be set to 0, and provides the operators == and !=, but only for member function pointers of the same class.
     Any member function pointer can be compared with 0 to see if it is null.  
     Unlike simple function pointers, the inequality comparisons (<, >, <=, >=) are not available.
**** as template type
     Like function pointers, they can be used as non-type template parameters, but this seems to work on fewer compilers.
**** restrictions
     Member function pointer can only point to member functions of a single class.
     you can't use a member function to point to a static member function.
     when dealing with derived classes, there are some surprises. 

**** static member function
     have to use a normal function pointer.
     Cannot use a member function pointer to point to a static member function.
**** inheritance
     member function pointer of a base_class member function cannot point to a member function of a publicly derived class. This is different from normal pointers.class.
***** example code
      SomeClass {
      public: 
      virtual void some_member_func(int x, char *p) {
      printf("In SomeClass"); };
      };
      
      class DerivedClass : public SomeClass {
      public:
      // If you uncomment the next line, the code at line (*) will fail!
      //    virtual void some_member_func(int x, char *p) { printf("In DerivedClass"); };
      };
      
      int main() {
      // Declare a member function pointer for SomeClass
      
      typedef void (SomeClass::*SomeClassMFP)(int, char *);
      SomeClassMFP my_memfunc_ptr;
      my_memfunc_ptr = &DerivedClass::some_member_func; // ---- line (*)
      }
*** delegate
*** polymorphism
**** essential
     = public inheritance 
     + base class pointers (or references) 
     + virtual functions.
**** example
     void func(const base_class &base_obj) {
     // do something
     }
     // even if we pass a derived_class object, 
     // the right function (derived version) will be called.
     func(base_obj);
     func(derived_obj);
*** virtual methods
**** background
     a pointer to the base class can point to a derived class
     a reference to the base class can reference a derived class
**** when to use
     if a base class pointer (or reference) points to (or references) a derived class object and call a member function that is overriden in the derived class, the base member function will still be used. So if you want to use the derived version, you need to specify the method in the base class to be "virtual".
**** virtual methods called from other methods is still polymorphic
     http://www.cs.bu.edu/teaching/cpp/polymorphism/intro/ part 11
     virtual float base_class::member_func_a() const {
     }
     void base_class::member_func_b() const {
     member_func_a;
     }
     float derived_class::member_func_a() const {
     // something overriding the base_class definition
     }
     // then we call member_func_b on derived_class pointer or reference
     // which version of member_func_a will be called?

     // answer: the derived_class version. since member_func_a is essentially
     // this->member_func_a. and "this" is pointing to a derived_class object.
**** once a method is virtual, it is virtual in all derived classes as well.
**** it's a good practice to explicitly label it as virtual in derived classes as a reminder.
*** class
**** private vs. protected
     protected members are acessible from derived classes and private are not
*** inheritance
**** Public inheritance
     public remain public
     protected remain protected
     private not accessible
***** pointer to base class can point to an object of itself and of any publicly-derived class.
***** if a base class pointer points to a derived class object and call a member function that is overriden in the derived class, the base member function will be used.
      it is the type of the pointer (i.e., Employee), not the type of the object it points to (i.e., possibly Manager) that determines which version will be called.
**** Private inheritance
     Public become private
**** Protected inheritance
     Public become protected
*** enum
    There are two kinds of enum type declarations. One kind creates a named type, as in
    enum MyEnumType { ALPHA, BETA, GAMMA };
    If you give an enum type a name, you can use that type for variables, function arguments and return values, and so on:
    enum MyEnumType x;  /* legal in both C and C++ */
    MyEnumType y;       // legal only in C++
    The other kind creates an unnamed type. This is used when you want names for constants but don't plan to use the type to declare variables, function arguments, etc. For example, you can write
    enum { HOMER, MARGE, BART, LISA, MAGGIE };
    enum TYPE {A,B,C,D}
    typedef enum {EMPL_PLAIN, EMPL_MANAGER} KindOfEmployee;
    KindOfEmployee kind;
    // then "kind" can only take EMPL_PLAIN(0) or EMPL_MANAGER(1).
*** namespace
**** to declare
     namespace net_connect
     {
     int make_connection();
     int test_connection();
     // so forth...
     }
**** to use
     net_connect::make_connection()
**** using namespace
     using namespace_name; // used only in the current scope
     using namespace namespace_name; // used globally
     using namespace_name::thing;
**** anonymous namespace
     when the program is compiled, the anonymous namespace will be accessible within the same file. In effect, it's as though an additional "using" clause was included implicitly. This effectively limits the scope of anything in the namespace to the file level (so you can't call the functions in that namespace from another other file).
     相当于C的static.
***** definition
      namespace
      {
      // functions
      }
**** rename namespace
     if a namespace is too long, one can:
     namespace <new> = <old>
*** random number generation
    random()
*** using a variable number of arguments
    #include <cstdarg>
    va_list
    va_start
    va_arg
    va_end
*** <iomanip>
    cout << setw(10) << "ten" << "four" << "four";
    ten          fourfour
    cout << setfill('-') << setw(80) << "-" << endl;
    ----------------------------------------------
    
*** <iostream>
    设置左右对齐。
    cout.width(6);
    cout << left << n << endl;
    cout << internal << n << endl;
    cout << right << n << endl;
    设置等宽table column打印
    cout << setw(field_one_width) << left << first_string;
    cout << " ";
    cout << setw(field_two_width) << left << second_string;
    设置浮点数精度
    cout << setprecision(3) << 2.71828
    设置八进制和十六进制
    std::cout << setbase(16) << 342;
    std::dec, std::oct and std::hex are shorthands for setbase(10), setbase(8) and setbase(16)
    打印前缀0 and Ox
    cout << hex << showbase << n << endl;
    cout << hex << noshowbase << n << endl;
    cout.flags( ios::right | ios::hex | ios::showbase )
** C
*** C中各变量大小
char 8 bytes but allowed to be wider
unsigned char 0..255 
signed char -127..127

A plain char(without the prefix 'signed' or 'unsigned') is either the one or the other. The compiler chooses for you and it most likely bases that choice on the way both of them can be implemented on your hardware.


short: 2 bytes
int: 4 bytes
long: 4 bytes (on some machine,8 bytes)

float: 4 bytes
double: 8 bytes
*** how to define global variable (across files)
The clean, reliable way to declare and define global variables is to use a header file file3.h to contain an extern declaration of the variable. The header is included by the one source file that defines the variable and by all the source files that reference the variable. For each program, one source file (and only one source file) defines the variable. Similarly, one header file (and only one header file) should declare the variable.

file3.h
#+begin_src c
  extern int global_variable;  /* Declaration of the variable */
#+end_src

file1.c
#+begin_src c
  #include "file3.h"  /* Declaration made available here */
  
  /* Variable defined here */
  int global_variable = 37;    /* Definition checked against declaration */
  
  int increment(void) { return global_variable++; }
#+end_src

file2.c
#+begin_src c
  #include "file3.h"
  #include <stdio.h>
  
  void use_it(void)
  {
      printf("Global variable: %d\n", global_variable++);
  }
#+end_src
*** type
**** c string (char *) to string
C++ strings have a constructor that lets you convert C-style strings:
#+begin_src c++
  char* myStr = "This is a C string!";
  std::string myCppString = myStr;
#+end_src
*** IO
**** getopt - get command line options
the synopsis, note that the variable optind, opterr and optopt are extern
#+begin_src c
  #include <unistd.h>
  
  int getopt(int argc, char * const argv[],
             const char *optstring);
  
  extern char *optarg;
  extern int optind, opterr, optopt;
#+end_src

an example
#+begin_src c
  #include "unistd.h"             /* for getopt */
  while((c = getopt(argc, argv, "A:l:w:q:N:p:I:Q:L:brdR:c:M:h:k:")) >= 0){
    switch(c) {
    case 'A': estimate_max_ins = atoi(optarg);            break;
    case 'l': flanking_size = atoi(optarg);               break;
    default: fprintf(stderr, "Unrecognized option '-%c'.\n", c);
      return 1;
    }
   }
  
#+end_src

another example from wikipedia
#+begin_src c
  #include <stdio.h>     /* for printf */
  #include <stdlib.h>    /* for exit */
  #include <unistd.h>    /* for getopt */
  int main (int argc, char **argv) {
    int c;
    int digit_optind = 0;
    int aopt = 0, bopt = 0;
    char *copt = 0, *dopt = 0;
    while ( (c = getopt(argc, argv, "abc:d:012")) != -1) {
      int this_option_optind = optind ? optind : 1;
      switch (c) {
      case '0':
      case '1':
      case '2':
        if (digit_optind != 0 && digit_optind != this_option_optind)
          printf ("digits occur in two different argv-elements.\n");
        digit_optind = this_option_optind;
        printf ("option %c\n", c);
        break;
      case 'a':
        printf ("option a\n");
        aopt = 1;
        break;
      case 'b':
        printf ("option b\n");
        bopt = 1;
        break;
      case 'c':
        printf ("option c with value '%s'\n", optarg);
        copt = optarg;
        break;
      case 'd':
        printf ("option d with value '%s'\n", optarg);
        dopt = optarg;
        break;
      case '?':
        break;
      default:
        printf ("?? getopt returned character code 0%o ??\n", c);
      }
    }
    if (optind < argc) {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
        printf ("%s ", argv[optind++]);
      printf ("\n");
    }
    exit (0);
  }
#+end_src
**** getopt_long - gnu long option
#+begin_src c
  #include <stdio.h>     /* for printf */
  #include <stdlib.h>    /* for exit */
  #include <getopt.h>    /* for getopt_long; standard getopt is in unistd.h */
  int main (int argc, char **argv) {
    int c;
    int digit_optind = 0;
    int aopt = 0, bopt = 0;
    char *copt = 0, *dopt = 0;
    static struct option long_options[] = {
      {"add", 1, 0, 0},
      {"append", 0, 0, 0},
      {"delete", 1, 0, 0},
      {"verbose", 0, 0, 0},
      {"create", 1, 0, 'c'},
      {"file", 1, 0, 0},
      {NULL, 0, NULL, 0}
    };
    int option_index = 0;
    while ((c = getopt_long(argc, argv, "abc:d:012",
                            long_options, &option_index)) != -1) {
      int this_option_optind = optind ? optind : 1;
      switch (c) {
      case 0:
        printf ("option %s", long_options[option_index].name);
        if (optarg)
          printf (" with arg %s", optarg);
        printf ("\n");
        break;
      case '0':
      case '1':
      case '2':
        if (digit_optind != 0 && digit_optind != this_option_optind)
          printf ("digits occur in two different argv-elements.\n");
        digit_optind = this_option_optind;
        printf ("option %c\n", c);
        break;
      case 'a':
        printf ("option a\n");
        aopt = 1;
        break;
      case 'b':
        printf ("option b\n");
        bopt = 1;
        break;
      case 'c':
        printf ("option c with value '%s'\n", optarg);
        copt = optarg;
        break;
      case 'd':
        printf ("option d with value '%s'\n", optarg);
        dopt = optarg;
        break;
      case '?':
        break;
      default:
        printf ("?? getopt returned character code 0%o ??\n", c);
      }
    }
    if (optind < argc) {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
        printf ("%s ", argv[optind++]);
      printf ("\n");
    }
    exit (0);
  }
#+end_src
**** standard usage information
#+begin_src c
  namespace {
    const int DEFAULT_FLANKING_SIZE = 500; // l
    const int DEFAULT_ASSEMBLE_READ_QUAL = 1; // q
    const int DEFAULT_NUM_MISMATCH_POOR_MAP = 5; // N
    const int DEFAULT_HIGH_DEPTH_SKIP = 1000; // p
    const int DEFAULT_PAD_LOCAL_REF = 200; // w
    const int DEFAULT_MIN_SIZE_THRESHOLD = 3; // M skip those with input size smaller than 3
    const int DEFAULT_MAX_NODE = 100; // h
    const string DEFAULT_KMERS = "15,25";
  
    void usage() {
      fprintf(stderr, "\n./tigra_sv <SV file> <a.bam> <b.bam> ...\n\n");
      fprintf(stderr, "\n Or: ./tigra_sv <SV file> <bam_list_file>\n\nOptions: \n");
      fprintf(stderr, "    -l INT     Flanking size for assembly [%d] bp\n", DEFAULT_FLANKING_SIZE);
      fprintf(stderr, "    -c STR     Only assemble calls on specified chromosome\n");
      fprintf(stderr, "    -R STR     Reference file location with the full path\n");
      fprintf(stderr, "    -q INT     Only assemble reads with mapping quality > [%d]\n", DEFAULT_ASSEMBLE_READ_QUAL);
      fprintf(stderr, "    -N INT     Number of mismatches required to be tagged as poorly mapped [%d]\n", DEFAULT_NUM_MISMATCH_POOR_MAP);
      fprintf(stderr, "    -p INT     Ignore cases that have average read depth greater than [%d]\n", DEFAULT_HIGH_DEPTH_SKIP);
      fprintf(stderr, "    -r         Write local reference to a file with .ref.fa as the suffix\n");
      fprintf(stderr, "    -d         Dump reads to fasta files\n");
      fprintf(stderr, "    -I STR     Save output files into an existing directory\n");
      fprintf(stderr, "    -w INT     Pad local reference by additional [%d] bp on both ends\n", DEFAULT_PAD_LOCAL_REF);
      fprintf(stderr, "    -b         Check when the input format is breakdancer\n");
      fprintf(stderr, "    -M INT     Skip those calls with input size smaller than [%d]\n", DEFAULT_MIN_SIZE_THRESHOLD);
      fprintf(stderr, "    -h INT     Maximum node to assemble, by default [%d]\n", DEFAULT_MAX_NODE);
      fprintf(stderr, "    -k STR     List of kmer sizes to use as a comma delimited string [%s]\n", DEFAULT_KMERS.c_str());
      fprintf(stderr, "Version: %s (commit %s)\n", __g_prog_version, __g_commit_hash);
    }
  }
  
#+end_src

*** C string
**** in-place string swapping using XOR(^)
#+begin_src c
  #include <stdio.h>
  
  void strrev(char *p)
  {
    char *q = p;
    while(q && *q) ++q;
    for(--q; p < q; ++p, --q)
      *p = *p ^ *q,
      *q = *p ^ *q,
      *p = *p ^ *q;
  }
  
  int main(int argc, char **argv)
  {
    do {
      printf("%s ",  argv[argc-1]); strrev(argv[argc-1]);
      printf("%s\n", argv[argc-1]);
    } while(--argc);
  
    return 0;
  }
#+end_src
** LaTeX
*** 用pdflatex emacs写文档
    C-c C-e document 自动提示documentclass，填充\begin{document} \end{document}
    
*** minipage with borders
\fbox{
\begin{minipage}
...
\end{minipage}
}

**** \usepackage{fullpage}   全页显示
算法
需安装texlive-science

*** 目录 tableofcontents:
\tableofcontents        通常放在标题页和摘要的后面
须运行两次latex以便更新tableofcontent
\setcounter{tocdepth}{2}        出现在目录表中的章节深度
深度计数从chapter（report and book)，section(article) 开始
\secnumdepth
include references into Table of contents:
right before the bibliograph command add,
\addcontentsline{toc}{section}{References}

To add a list of tables, after \tableofcontents, add,
\listoftables

To add a list of figures, after \tableofcontents, add,
\listoffigures

If you don't want some headings to be included,e.g. if you don't want Preface to be numbered, you'd use commands:
\subsection*{Preface}
\addcontentsline{toc}{subsection}{Preface}

*** 字体
\small
\bfseries - 黑体
\em     - 斜体
*** 段落
\setlength{\长度命令｝｛已定义的长度｝  /*FMARK_START*/
\setlength{\parindent}{0.5cm}   第一行的缩进设为0.5cm
\setlength{\textwidth}{12.5cm}  一行的长度
\setlength{\parskip}{1ex plux0.5ex minus0.2ex} - 两行间距（\parskip)等于当前字体中x的高度，但是可以伸长0.5或收缩0.8 (橡皮长度)
\renewcommand{\baselinestretch}{1.5}  字母基线间距(忽略诸如g,y字母下挂) 增加至1.5倍
\baselineskip   绝对行距(== \baselinestretch * 给定字体的默认行距)
\fill   正常长度0,可伸展至任何长度。
\setlength{\oddsidemargin}  奇数页左边界
\setlength{\evensidemargin} 偶数页左边界
\setlength{\topmargin}      页顶到页眉
\setlength{\headheight}     页眉高度
\setlength{\headsep}        页眉基线到正文顶部
\setlength{\headheight}     页眉高度
\setlength{\topskip}        正文顶部到正文第一行基线距离
\setlength{\textheight}     正文高度
\setlength{\textwidth}      正文宽度
\setlength{\footskip}       正文底部到页脚底部
**** 设置单词断点
man\-u\-script
**** 单双列页面
\twocolumn[整列文字]
\onecolumn
*** 宏包使用
\usepackage[选项1，选项2...]{宏包1，宏包2, ...}
*** 命令字符, 需要escape的字符:
\$
\&
\%
\#
\_
\{
\}
*** 数学
**** 特殊数学集合符号：
     Special symbols
     \usepackage{amsfonts} 或者 \usepackage{amssymb}.
     \mathbb{set}
     Examples:
     \mathbb{P} for prime numbers
     \mathbb{N} for natural numbers
     \mathbb{Z} for integers
     \mathbb{I} for irrational numbers
     \mathbb{Q} for rational numbers
     \mathbb{R} for real numbers
     \mathbb{C} for complex numbers
     Positive real numbers can now be easily expressed :
     \mathbb{R}_{\geq0} by typing \mathbb{R}_{\leq0}.
**** dispay math mode
     \[ ... \] or \begin{equation} ... \end{equation}
     or \begin{align} ... \end{align}
**** 定理和证明
     \usepackage{amsthm}
***** 定理
      \newtheorem{定理标签}{定理名}
      \begin{定理标签}
      \end{定理标签}
      定理名是在pdf中显示的title
****** 自定义定理
       \newtheoremstyle{stylename}% name of the style to be used
       {spaceabove}% measure of space to leave above the theorem. E.g.: 3pt
       {spacebelow}% measure of space to leave below the theorem. E.g.: 3pt
       {bodyfont}% name of font to use in the body of the theorem
       {indent}% measure of space to indent
       {headfont}% name of head font
       {headpunctuation}% punctuation between head and body
       {headspace}% space after theorem head; " " = normal interword space
       {headspec}% Manually specify head
       以上需要按顺序输入，空变量表示使用默认值。
       e.g., headspec可以是：\thmname{#1}\thmnumber{#2}:\thmnote{#3}
       参看：http://en.wikibooks.org/wiki/LaTeX/Theorems
***** 证明
      \begin{proof}
      \end{proof}
****** 自定义证明标题
       \begin{proof}{Proof for an important theorem}
       \end{proof}
**** 大括号样式
*** 文档类
    \documentclass[选项]{类}
    类:
    可以是 book report article 或 letter.
    article:  parts sections subsections
    report:   chapter part
    book:     book，对奇偶页区别对待并打印页眉页脚
**** 选项:
- 字体  10pt(默认) 或 11pt 12pt
- 纸张大小 letterpaper(默认) a4paper a5paper legalpaper executivepaper b5paper
- 默认竖直，可用landscape调为横向。
- 页面格式 onecolumn twocolumn (\columnsep 和 \columnseprule 调整列间距)
- 区分奇偶页 oneside twoside(页码在右当奇数，页码在左当偶数）
- 每章开始位置 openright openany
- 标题页 notitlepage(标题非单独一页） titlepage(标题单独一页）
- 公式编号在左 leqno
- 公式左对齐而不是居中fleqn (\mathindent 调整缩进大小）
\setlength{\mathindent}{2.5cm}
- 参考文献格式 openbib
- draft 在右边界突出的文本会加上粗黑标识。
- final 无粗黑标识
***** 例子:
\documentclass[11pt,twoside,fleqn]{article}
**** 页面样式, 页眉
\pagestyle{样式｝
样式可取：
plain(默认)     无页眉，中间页码
empty           无页眉也无页码
headings        页眉为章节标题。页脚为空
myheadings      页眉自定义，使用markright和markboth
\markright{右页眉}
\markboth{左页眉}{右页眉｝  - 适用于\twoside
\thispagestyle  同\pagestyle 但仅对当前页起作用
**** 页编号, 页码
\pagenumbering{数字形式}
数字形式可取
arabic
roman   小写罗马数字
Roman   大写罗马数字
alpha   小写字母
Alpha   大写字母
常用的样式是在前言设罗马数字
\pagenumbering{roman}
紧接第一个\chapter用\pagenumbering{arabic}
**** 标题
\title{My Title}
\author{You \thanks{Tel.00001-1234 FRG} \\
Max--Planck--Insitute \\
\and 
Me
\thanks{Tel.
4131231-32 USA
University of Iowa}
\date{日期文本}
\maketitle
\and 可用 \\ 取代，这样多作者上下排列
\thanks{脚注文本}
**** 摘要 abstract
\begin{abstract}
\end{abstract}
**** 章节
\章节命令［短标题］｛标题｝
\章节命令＊{标题}        - 不打印节号，不出现在目录中
章节命令包括 \part \chapter \section \subsection \subsubsection \paragraph \subparagraph
短标题用于目录和页眉
\part 对命令编号没有影响.
article 中， \part 第0层
book and report 中， \chapter 第0层
改变编号深度 \setcounter{secnumdepth}{数}
设定某章节名称的计数器:
\setcounter{章节名称}{数}
e.g. \setcounter{chapter}{2}    设定chapter的计数器为2 (下次调用chapter时，将看到chapter 3)
*** 附录
\appendix
或者
\begin{appendix}
\end{appendix}
*** 引用
    \label{mylabel}
    \ref{mylabel}
    \pageref{mylabel}
*** 书的结构
\frontmatter    前言，目录      罗马数字页码，无章编号
\mainmatter     主体            阿拉伯数字页码，有章编号
\backmatter     参考文献，索引，版本记录        无章编号
*** figure
figure caption
\caption[short caption]{full caption}
\rule[提升高度]{宽度｝｛高度｝  生成黑矩形
*** quote 环境
\begin{quote}
\end{quote}
white space:
'\ '
\hspace{20pt}
\vspace{20pt}
*** 日期
\today
\month
\year
*** units
pt  point         (1 in = 72.27 pt)
pc  pica          (1 pc = 12 pt)
in  inch          (1 in = 25.4 mm)
bp  big point     (1 in = 72 bp)
cm  centimetre    (1 cm = 10 mm)
mm  millimetre
dd  didot point   (1157 dd = 1238 pt)
cc  cicero        (1 cc = 12 dd)
sp  scaled point  (65536 sp = 1 pt)
em  字体相关的尺寸,大写M的宽度
ex  x的高度
*** dealing with floating objects:
\usepackage{placeins}. If you get the "too many unprocessed floats" throw in a \FloatBarrier and it forces LaTeX to dump all the floats before this point. I have an Appendix with 20 figures one after the other, I threw a \FloatBarrier in the middle and it solves all the issues. FloatBarrier is also great to get all floats within a section rather than letting it flow to the next section.
Or use \clearpage or \cleardoublepage
*** table with cell auto-wrap:
use p{dimen} as the column specification.
Actually, this command specified the width of the cell
\begin{tabular}{|l|l|r|p{2in}|}
insert packages:
pressing <C-j> in insert mode takes you to the next <++> in the text
"amsmath" + <F5>
insert equations:
"eqnarray" + <F5>
shortcuts:
e^^ => e^{}
\pi => `p
&=& => ==
**** fold in latex-suite:
\rf: fold entire file/refresh folds.
za: toggle between fold and unfold.
**** add citation:
\ref{} or \cite{} in the curly braces, press <F9> is gonna reference bibliographic entries.
<F9> also work for searching filenames for \inputgraphics command and just plain searching for words.
**** compilation:
\ll compile the tex file into .dvi.
\lv view the dvi file created.
To change default to pdf format:
add:
    let Tex_DefaultTargetFormat="pdf"
    let g:Tex_DefaultTargetFormat="pdf"
    let g:Tex_ViewRule_pdf="xpdf"
    let g:Tex_CompileRule_pdf="pdflatex -interaction=nonstopmode $*"
    set sw=2
    set iskeyword+=:
    let g:Tex_MultipleCompileFormats="pdf"      # this one run bibtex/pdflatex sufficiently many times.
in .vim/ftplugin/tex.vim
**** view latex-suite help file:
help latex-suite.txt
help latex-suite-quickstart.txt
***** add Template:
:TTemplate
others: 
{\LaTeX}
{\LaTeXe}
或\LaTeX{} 或\LaTeX\
*** long equation breaking techniques
**** use split package from amsmath
    \begin{equation}
    \begin{split}
    E_{cp}=\{\{u,v\} \mid \{u,v\} \subseteq E_t  \textrm{ or } \{u,v\} \subseteq E_h \\
    \textrm{ for some }(E_t,E_h) \in \mathcal{E}\}.
    \end{split}
    \end{equation}
**** use eqnarray
     \begin{eqnarray}\nonumber
     N(v) &=& \{v\} \cup \{u \in V \mid \{u,v\} \subseteq E \\
     && \textrm{ for some }E \in \mathcal{E}\}.
     \end{eqnarray}
***** nonumber guarantee that there is no label for the first part
*** multiline subscript
**** use substack
     \sum_{\substack{0\le i\le m\\  0<j<n}} P(i,j)
**** use subarray environment
     \sum_{\begin{subarray}{l}
     i\in\Lambda\\  0<j<n
     \end{subarray}}
     P(i,j)
** Perl
*** find help
    perldoc -f eval
    sudo apt-get install perl-doc
*** build a perl module
    ExtUtils::MakeMaker
*** one command perl
    cat lpm.spi | perl -p -e 's/(XU\d+) /\1 VVD /;' >lpm_new.spi
*** to read command line argument
    argument = shift;
*** 命令行perl
    perl -ne 'print if /^(Subject|From):/' Mailbox ## Mailbox is a file.
    perl -pe 's/1999/2000/g' newyear.txt	## substitute and print out again
    perl -ne 'next if /^s/;print' strictvar.pl	## print only those lines that don't start with a hash sign(#).
**** -e  
     specified the one-line to be executed.
**** -n 
     causes Perl to assume the following loop around your script, which makes it iterate over filename arguments somewhat like sed -n or awk:
     
     while (<>) { ... # your script goes here }
     
     The lines are not printed by default. You need to use -p to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it, and moves on to the next file. 
**** -p 
     causes Perl to assume the following loop around your script, which makes it iterate over filename arguments somewhat like sed:

     while (<>) { ... # your script } continue { print or die "-p destination: $!\n";}

     To suppress printing use the -n switch. A -p overrides a -n switch. If a file named by an argument cannot be opened for some reason, Perl warns you about it, and moves on to the next file. Note that the lines are printed automatically. An error occurring during printing is treated as fatal. 
** Lisp
*** Query PGDB from pathway-tools
A sample session
$ pathway-tools -lisp
;; Select E. coli as the current organism 
EC(1): (select-organism :org-id 'ecoli)
ECOLI

;; Count the number of genes in the KB.
EC(1): (length (get-class-all-instances '|Genes|))
4425

;; Find all genes whose nucleotide position on the chromosome is
;; less than 10,000.
EC(3):  (loop for x in (get-class-all-instances '|Genes|)
for pos = (get-slot-value x 'left-end-position)
when (and pos (< pos 10000))
collect x)
(EG11512 EG11555 EG10998 EG11000 EG10999 EG11556
 EG11511 G6081 EG10011 EG11277)

;; Set variable g to the previous result.
EC(4): (setq g *)
(EG11512 EG11555 EG10998 EG11000 EG10999 EG11556
 EG11511 G6081 EG10011 EG11277)
;; Load the example.lisp file from the PTools web site, which

;; defines various additional functions.  You can write you own
;; additional functions in such files.
EC(5): (load "~/examples")

;; Loading ~/examples.lisp
;; Print the previously generated list of genes as a table.
EC(6): (object-table g)
EG11512                             b0010
EG11555                             b0007
EG10998                             thrA
EG11000                             thrC
EG10999                             thrB
EG11556                             talB
EG11511                             mog
G6081                               b0005
EG10011                             b0006
EG11277                             thrL
NIL

;; End our session
EC(7): (exit)
; killing "Initial Lisp Listener"
; Exiting Lisp

To abort an error
:continue 4

store queries in file
You can create a .lisp file containing functions that you define that store queries and associated functions so that you can reuse them in the future. 

The file will define one or more Lisp functions (procedures). For example, the following file defines a function that counts the number of monomers present in the current DB. All lisp files you create for use with the Pathway Tools should begin with the line (in-package :ecocyc) to select the proper Lisp package (namespace).
(in-package :ecocyc)
(defun num-monomers ()
  (length (get-class-all-instances '|Polypeptides|))
  )
To define or redefine this function within your Lisp session, load the file using the Lisp load function. If the preceding file was called monomers.lisp in your home directory, you could load it into your session by typing:
(load "~/monomers")

Cooper book (Basic Lisp Techniques)
With Franz ACL
you can use pathway-tools -lisp to try

to exit
(excl:exit) 
strong exit
(excl:exit 0 :no-unwind t) 
a short cut, the toplevel command
:exit

prepare a source file /tmp/hello.lisp, make /tmp/hello.fasl (the fast load compiled machine-code file)
(in-package :user) 
(defun hello () 
(write-string "Hello, World!")) 

to compile a source file
EC(1): (compile-file "/tmp/hello") 
;;; Compiling file /tmp/hello.lisp 
;;; Writing fasl file /tmp/hello.fasl 
;;; Fasl write complete 
#P"/tmp/hello.fasl" 
NIL 
NIL 
to load (you can load without compiling, the source will be compiled automatically)
EC(2): (load "/tmp/hello") 
; Fast loading /tmp/hello.fasl 
T 

switch namespace and then call hello function
(in-package :user)
CL-USER(3): (hello) 
Hello, World! 
"Hello, World!




Tips on using Allegro Common Lisp
http://www.cs.utexas.edu/~mooney/cs351/allegro-tips.html

Abort an error
If an error occurs, the Lisp interpreter will invoke the "break package" with error message and a different prompt. To simply exit from the error, type ":res" for "resume" and it will abort the run and return to the top-level prompt. For example: 
USER(1): (rest 3)
Error: Attempt to take the cdr of 3 which is not listp.
  [condition type: SIMPLE-ERROR]
[1] USER(2): :res
USER(3): 

Abort a run
C-c C-c
Then :res

Format
~%: newline forced
~&: newline when necessary
~T: tab
http://www.gigamonkeys.com/book/a-few-format-recipes.html
Some resources

Common lisp cook book
http://cl-cookbook.sourceforge.net/index.html

Practical common lisp
http://www.gigamonkeys.com/book/

ACL online free training
http://www.franz.com/services/classes/

ACL documentation
http://franz.com/support/documentation/current/doc/

ANSI common lisp specification
http://www.franz.com/support/documentation/current/ansicl/ansicl.htm

resource center from ACL
http://www.franz.com/newtolisp/index.lhtml

MIT opencourseware
http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/
On Lisp
/home/wanding/sync/Books/Programming/Lisp/onlisp.pdf

SBCL
http://www.sbcl.org/
http://cs.gmu.edu/~sean/lisp/

common lisp the language
http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/clm.html
** Java
*** Basic concepts

Java version history
http://en.wikipedia.org/wiki/Java_version_history
JDK 1.0 → JDK 1.1 → J2SE 1.2 → … → J2SE 1.4 → J2SE 5.0 → Java SE 6 → Java SE 7

There are three implementations of Java on Ubuntu, openjdk, sun java and ibm java. Most likely you're gonna need openjdk and sun java. I like openjdk because it comes with nice font and look and feel.
openjdk package: openjdk-6-jre + icetea6-plugin (the browser plugin) + openjdk-6-jdk
sun java package: sun-java6-jre + sun-java6-plugin (the browser plugin) + sun-java6-jdk

*** to change java running environment:
sudo update-java-alternatives --set java-6-sun

*** to list all java implementation on your computer:
update-java-alternatives --list

*** to show the java you are currently running:
java -version

Source file name has to be spelled the same (case sensitive) as the name of the public class contained.
e.g., ImageViewer.java has public class ImageViewer

.java : source file to be compiled to .class by javac command
.class : byte code compiled and run by JVM
.jar : a collection of .class

*** what's main method signature
public static void main(String args[])
public means it's accessible from outside the class.

// for comments

; for ending a statement

the following are equivalent
1. String[] args
2. String []args
3. String args[]

*** Ant
build javadoc in ant
need javadoc.xml
ant -buildfile javadoc.xml html

build java library using ant
need build.xml
ant # this build the default target 'dist-all' in the default file 'build.xml'
** CMake
﻿1. in-source build:
cd src/
ccmake .  ## this will look for the CMakeLists.txt in the current directory
make
1. out-of-source build:
   mkdir build
   cd build
   ccmake ../src
   make
   Warning: there shouldn’t be any CMakeCache.txt in src/
1. cmake -DCMAKE_BUILD_TYPE=Debug
2. cmake -DCMAKE_BUILD_TYPE=Release
3. add_executable - add an executable to the project using the specified source files
add_executable(<name> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source2, ... sourceN)
<name> is also made a globally unique logical target name, which might be used to be fed into target_link_libraries.
add_executable(MolAligner ${CXX_MAIN} ${CXX_SOURCES} ${MOC_FILES})
1. project - set a name for the entire project
        project(<projectname> [languageName1 languageName2 ...])
        one can specify which languages the project supports. languageName can be CXX, C, Fortran, etc.
        project(MolAligner)
1. find_package - load settings for an external project
        find_package(<package> [version] [EXACT] [QUIET] [[REQUIRED | COMPONENTS] [components...]] [NO_POLICY_SCOPE])
        This command usually executes the Find<package>.cmake file in the CMAKE_MODULE_PATH which is specified by the cmake installation. This command set a bunch of package-specific variables.
        see Standard CMake Modules section for a list of packages, note that the name of the module (e.g., FindQt4) is not the same as the name of the package (e.g. Qt4).
        find_package(Qt4 REQUIRED)
        find_package(Qt4 4.4.3 COMPONENTS QtCore QtGui QtXml REQUIRED)
        If no Find<package>.cmake can be found in CMAKE_MODULE_PATH, then cmake looks for <name>Config.cmake or <lower-case-name>config.cmake in the <package>_DIR directory. 
        see cmake documentation for detail
1. cmake_minimum_required - set the minimum required version of cmake for  a project
        cmake_minimum_required(VERSION major[.minor[.patch]] [FATAL_ERROR])
        this implicitly calls cmake_policy function, see documentation
        cmake_minimum_required(VERSION 2.8)
1. set - set a CMAKE variable to a given value
        set(<variable> <value> [[CACHE <type> <docstring> [FORCE]] | PARENT_SCOPE])
        <type> and <docstring> are required when CACHE is present.
        If <value> is not specified then the variable is removed instead of set (equivalent to unsert() command). 
        set(CXX_SOURCES
      ${CMAKE_SOURCE_DIR}/mol_render.cpp
      ${CMAKE_SOURCE_DIR}/mainwindow.cpp
              ${CMAKE_SOURCE_DIR}/molecule.cpp
              ${CMAKE_SOURCE_DIR}/layout_gen.cpp
)
set(CMAKE_CXX_FLAGS “${CMAKE_CXX_FLAGS} -Wno-deprecated -O2”)
1. QT4_WRAP_CPP - create moc code from a list of files containing Qt class with the Q_OBJECT declaration. 
        
        options can be added such as those found by executing “moc -help”
        QT4_WRAP_CPP(MOC_FILES ${CXX_QOB_HEADERS})
1. include_directories - ddd include directories to the build
        include_directories([AFTER|BEFORE] [ SYSTEM] dir1 dir2 ...]
        By default, the directories are appended to the current list of directories (AFTER behavior). But one can toggle to BEFORE to prepend the directories.
        include_directories(${QT_QTSQL_INCLUDE_DIR})
1. target_link_libraries - link a target to a given libraries
        target_link_libraries(<target> [item1 [item2 [...]]] [[debug|optimized|general] <item>] ...)
        Library dependencies are transitive by default. When this target is linked into another target then the libraries linked to this target will appear on the link line or the other target too.
        Although one can link either a library or an executable, the link command would be issued only when the executable is built.
        CMake will generate a dependency for the executable on the library. Always remember that CMake script is a meta-compilation system. It doesn’t have to follow the order of the real compilation.
        target_link_libraries(MolAligner ${QT_LIBRARIES} ${QT_QTSQL_LIBRARY})
1. add_subdirectory - add a subdirectory to the build
        add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])
        If source_dir is a relative path, it will be interpreted with respect to the current directory.
        binary_dir specify the directory in which to place the output files. It’s default to the source_dir.
        add_subdirectory(test)
1. add_custom_target - Add a target with no output so it will always be built.
        add_custom_target(Name [All] [command1 [args1 ...]] 
         [COMMAND command2 [args2 ...] ...]
         [DEPENDS depend depend depend ...]
         [WORKING_DIRECTORY dir]
         [COMMENT comment] [VERBATIM]
         [SOURCES src1 [src2...]])
        If one wants to add dependency on non-file targets, he should consider add_dependencies. This command can be used to transfer file-dependency across directories.
        The target has no output and is always considered out of date.
add_custom_target(moc_is_ready DEPENDS ${MOC_FILES})
1. add_dependencies - add a dependency between top-level targets
        add_dependencies(target-name depend-target1 depend-target2 ...)
top-level targets include ones created by ADD_EXECUTABLE, ADD_LIBRARY, ADD_CUSTOM_TARGET.
        add_dependencies(test_render moc_is_ready)
1. configure_file - copy a file to another location and modify its contents
        configure_file(<input> <output> [COPYONLY] [ESCAPE_QUOTES] [@ONLY])
        Copies a file <input> to file <output> and substitutes variable values referenced in the file content.
        <input> must be a file, not a directory. <output> is an existing directory the input file is placed in that directory with its original name.
        This command replaces any variables in the input file referenced as ${VAR} or @VAR@ with their values as determined by CMake. If a variable is not defined, it will be replaced with nothing. If COPYONLY is specified, then no variable expansion will take place. 
configure_file(“${CMAKE_CURRENT_SOURCE_DIR}/test_molecule.ATP.dat””${CMAKE_CURRENT_BINARY_DIR}” COPYONLY)
1. string - 
2. message - 
        message(SEND_ERROR “You need Python”)
        message(${_py_file})
        message(“In directory var: ${var} LCV: ${LCV_SUB}”)
1. set_source_files_properties
set_source_files_properties(${MOC_FILES} PROPERTIES GENERATED 1)
1. foreach
        foreach(_py_file ${_py_files})
                configure_file(${_py_file} ${CMAKE_CURRENT_BINARY_DIR} COPYONLY}
        endforeach(_py_file)
1. file
file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/python/mysubdir)
        file(GLOB _py_files “*.py”)
1. add_library
add_library(uGraph SHARED ${CXX_SOURCE_STAND})
1. execute_process
execute_process(COMMAND ${CMAKE_COMMAND} -E copy_directory “${CMAKE_SOURCE_DIR}/pyHypergraph” “${CMAKE_BINARY_DIR}/pyHypergraph”)
1. set_target_properties
set_target_properties(uGraph PROPERTIES OUTPUT_NAME “Graph”)
1. Some useful variables
See www.cmake.org/Wiki/CMake_Useful_Variables
CMAKE_CXX_FLAGS - a feature not appearing in the official documentation
CMAKE_CURRENT_BINARY_DIR
CMAKE_CURRENT_SOURCE_DIR
CMAKE_BINARY_DIR
CMAKE_SOURCE_DIR
** GnuPlot
   http://gnuplot-tricks.blogspot.com/2009/11/broken-histograms.html
   file://home/wanding/sync/Books/Computing/gnuplot.pdf
   file://home/wanding/sync/Books/Computing/gpcard.pdf
   gnuplot demo
   http://gnuplot.sourceforge.net/demo/
   http://t16web.lanl.gov/Kawano/gnuplot/index-e.html
*** IBM tutorial
**** the basics
     help <command>
     q to quit
     
     plot sin(x)
     
     set xrange [-pi:pi]
     replot
     reset
     
     set title "My first graph"
     set xlabel "Angle. \n in degrees"
     set ylabel "sin(angle)"
     plot sin(x)
     
     set xrange [-pi:pi]
     # major tics have level 0, minor tics have level 1
     set xtics ("0" 0, "90" pi/2, "-90" -pi/2, "" pi/4 1, "" -pi/4 1, "" 3*pi/4 1, "" -3*pi/4 1)
     set grid
     set xlabel "Angle,\n in degrees"
     set ylabel "sin(angle)"
     plot sin(x)

     unset grid
     load "filename"
     
     pause -1

     set terminal png
     set output "output.png"
     replot

     set term aifm		# adobe illustrator
     set term corel		# corel draw
     set term dxf		# AutoCad
     eepic, latex, pstricks, texdraw, tpic and so on
     set ylabel "$sin(\\theta)$"	# latex output

     \input{output.tex}		# the output file in your latex file

     set term post enh		# enhanced PostScript, essentially PostScript with bounding boxes
     set out 'gplt.eps'
     set xlabel '{/Symbol q_1}'
     set ylabel 'sin^2({/Symbol q_1})'
     plot sin(x)**2

     # square is synonymous to an aspect ratio of 1;
     # scale y-axis by 2, retain x-axis size
     set size ratio square 1,2
     
**** plotting more than one curve
     plot sin(x), cos(x)
     
     unset xtics # keep all other things simple
     plot sin(x) with linespoints pointtype 5, cos(x)  w boxes lt 4
     
     set key top left
     set key box
     plot [-pi:pi] sin(x) title "sinusoid" with linespoints pointtype 5, cos(x) t 'cosine' w boxes lt 4

     set xrange [-pi:pi]
     
     # Uncomment the following to line up the axes
     # set lmargin 6
     # Gnuplot recommends setting the size and origin before going to
     # multiplot mode
     # this sets up bounding boexes and may be required on some terminals
     set size 1,1
     set origin 0,0

     # Done interactively, this takes gnuplot into multiplot mode
     # and brings up a new prompt ("multiplot >" instead of "gnuplot >")
     set multiplot

     # plot the first graph so that it takes a quarter of the screen
     set the size 0.5, 0.5
     set origin 0, 0.5
     plot sin(x)

     # plot the second graph so that it takes a quarter of the screen
     set size 0.5, 0.5
     set origin 0.5, 0.5
     plot cos(x)

     # plot the fourth graph so that it takes a quarter of the screen
     set size 0.5, 0.5
     set origin 0.5,0
     plot 1/cos(x)
     
     # on some terminals, nothings gets plotted until this command is issued
     unset multiplot

     # remove all customization
     reset
**** plotting data
     set xdata time		# the x axis data is time
     set timefmt "%d-%b-%y"	# the dates in the file look like 10-Jun-04
     set format x "%b %d"	# on the x axis, we want tics like Jun 10
     plot ["31-May-04":"11-Jun-04"] 'ibm.dat' using 1:2 with linespoints
     # "using 1:2" tells gnuplot to use the first column for x-axis and second column for y-axis.
     plot ["31-May-04":"11-Jun-04"] 'ibm.dat' using 1:($2+$3+$4+$5)/4:4:3 title 'daily prices, IBM' with yerrorbars # the format is x:y:ylow:yhigh

     set bar 5
     plot ["31-May-04":"11-Jun-04"] 'ibm.dat' using 1:2:3:4:5 with financebars 

     set datafile separator <string>
     set datafile commentschar <char>

     plot "< awk --f preprocess.awk data.file" # popen
     set datafile missing 'NaN'	# specify the symbol for not a number
     
     plot 'file'
     plot 'file' using 1:2
     plot 'file' using ($1):($2)

     help ternary
     plot 'file' using 1:($3>10 ? $2 : 1/0) # plot the second column as the y-value unless the third column is more than 10.

     A(jw) = ({0,1}*jw/({0,1}*jw+p1)) * (1/(1+{0,1}*jw/p2))
     p1 = 10
     p2 = 10000
     set dummy jw
     set grid x y2
     set key default
     set logscale xy
     set log x2
     unset log y2
     set title "Amplitude and Phase Frequency Response"
     set xlabel "jw (radians)"
     set xrange [1.1 : 90000.0]
     set x2range [1.1 : 90000.0]
     set ylabel "magnitude of A(jw)"
     set y2label "Phase of A(jw) (degrees)"
     set ytics nomirror
     set y2tics
     set tics out
     set autoscale  y
     set autoscale y2
     plot abs(A(jw)), 180/pi*arg(A(jw)) axes x2y2
     
     save set 'filename'
     save var <file>
     save func <file>
*** Duke University tutorial
    http://www.duke.edu/~hpgavin/gnuplot.html
**** plotting functions
     plot sin(x) / x
     splot sin(x*y/20)
     plot sin(x) title 'Sin Function', tan(x) title 'Tangent'
**** plotting data
     plot "force.dat" using 1:2 title 'Column',\
     "force.dat" using 1:3 title 'Beam'
     
     Abbreviation:
     u using
     t title
     w with

     plot "fileA.dat" using 1:2 title 'data A', \
     "fileB.dat" using 1:3 title 'data B'
     
     help splot datafile
     "splot" is about plotting 3D data
**** customizing your plot
     plot "force.dat" using 1:2 title 'Column' with lines, \
     "force.dat" u 1:3 t 'Beam' w linespoints

     plots may be in "lines, points, linespoints, impulses, dots, steps, fsteps, histeps, errorbars, xerrorbars, yerrorbars, xyerrorbars, boxes, boxerrorbars, boxxyerrorbars, financebars, candlesticks or vector."
     
     set title "Force-Deflection Data"
     set xlabel "Deflection (meters)"
     set ylabel "Force (kN)"
     set xrange [0.001:0.005]
     set yrange [20:500]
     set autoscale		# have gnuplot determine ranges
     set key 0.01, 100		# move the key, ## NOTE: key refers to the legend.
     unset key			# delete the key
     set label "yield point" at 0.003, 260 # Put a label on the plot
     unset label		# remove all labels
     set logscale
     unset logscale; set logscale y
     set xtics (0,002, 0.004, 0.006, 0.008)
     unset xtics; set xtics auto
     
     set datafile commentschars "#%" # change comment character
**** scripts
     gnuplot> load "force.p"

** SQLite
*** tutorial by Mike Chirico
    http://souptonuts.sourceforge.net/readme_sqlite_tutorial.html
**** common commands
     sqlite3 test.db  "create table t1 (t1key INTEGER PRIMARY KEY,data TEXT,num double,timeEnter DATE);"
     sqlite3 test.db  "insert into t1 (data,num) values ('This is sample data',3);"
     sqlite3 test.db  "insert into t1 (data,num) values ('More sample data',6);"
     sqlite3 test.db  "insert into t1 (data,num) values ('And a little more',9);"

     sqlite3 test.db  "select * from t1 limit 2";
     sqlite3 test.db  "select * from t1 order by t1key limit 1 offset 2";
     sqlite3 test.db ".table"	# show table names.
     sqlite3 test.db "select * from sqlite_master" # get table information from "sqlite_master"
     sqlite3 test.db ".dump"
     sqlite3 test.db ".dump"|sed -e s/t1/t2/|sqlite3 test2.db
**** triggers
     CREATE TRIGGER insert_t1_timeEnter AFTER INSERT ON t1
     BEGIN
     UPDATE t1 SET timeEnter = DATETIME('NOW')  WHERE rowid = new.rowid;
     END;
     
     sqlite3 test.db  "insert into t1 (data,num) values ('First entry with timeEnter',19);"
     sqlite3 test.db "select * from t1";
***** scripting in sqlite
      sqlite3 test.db < script
      Comments are preceded by "--".
**** Logging all inserts, updates and deletes.
**** UTC and localtime.
**** Other date and time commands.
**** The ATTACH command: Build a virtual table that spans multiple tables on separate databases.
**** The power of the SIGN function -- A mathematical explanation.
*** official tutorial
    http://www.sqlite.org/sqlite.html
** matlab
*** help commands
    help, lookfor, helpwin, helpdesk, demos
*** install matlab
    cd
    mkdir -p matlab_iso
    sudo mount -o loop /media/FlashDriv/ml2011au.iso /home/wanding/matlab_iso
    # loop means using the same device
    # or open iso with archive_mounter in ubuntu (right click)
    umount /home/wanding/matlab_iso
**** other libraries necessary (if complained)
     libXp (on fedora)
**** libc linking issue (on ubuntu) /oscheck.sh: 605: /lib64/libc.so.6: not found
     sudo ln -s /lib64/x86_64-linux-gnu/libc-2.13.so /lib64/libc.so.6
     for 32 bit system, find libc by "locate libc.so.6"
     on a 32-bit ubuntu, the solution is:
     sudo ln -s /lib/i386-linux-gnu/libc.so.6 /lib/libc.so.6
**** libc++ linking issue (on ubuntu) libc++.so.6: not found
     cd ~/MATLAB/R2011a/sys/os/glnx86
     mv libstdc++.so.6 libstdc++.so.6.orig
     mv libstdc++.so.6.0.10 libstdc++.so.6.0.10.orig
     the following is optional
     ln /usr/lib/x86_64-linux-gnu/libstdc++.so.6 libstdc++.so.6
*** pdf tutorials
    matlab quick tutorial
    file:/home/wanding/sync/Books/Computing/matlab_quick_tutorial.pdf
    matlab plotting tutorial
    file:/home/wanding/sync/Books/Computing/matlab_plotting_tutorial.pdf
*** website tutorials
**** official
     demos and webinars http://www.mathworks.com/products/demos/#
     mathworks support http:/www.mathworks.com/support
     self-training tutorial http://click.em.mathworks.com/?qs=f247efb39e1584fbfeca1b1b0f3057e24c1feab710f253cf6462ed49ac13a08dbee65a098fe39a8f
**** third party
     UFL Matlab tutorial http://www.math.ufl.edu/help/matlab-tutorial/
     matlab tips and tricks http://www.ee.columbia.edu/~marios/matlab/matlab_tricks.html
     SIU Matlab tutorial http://www.math.siu.edu/MATLAB/tutorials.html
     UCSD Matlab Primer http://www.math.ucsd.edu/~bdriver/21d-s99/matlab-primer.html
     MIT Matlab Wiki http://matlab.wikia.com/wiki/FAQ
*** get environment variable
    getenv("COMMUNITY_DATA")
*** run .m file from terminal
    matlab -nojvm -nodisplay -nosplash something.m
*** grammar
**** matrix multiplication
***** a * b
***** a .* b
      element-wise multiplication
***** a ./ b
      element-wise division
***** a .^2
      element-wise power
**** matrix creation
     eye(3); zeros(3); ones(3)
**** matrix filtration
     y(t()<=1) = t(t()<=1);
     y(t()>1) = 1./ t(t()>1);
**** data import/export
***** load filename
      load all variables in filename
***** load filename x
      load variable x from filename
***** load filename a*
      load all variable start with a from filename
***** save filename
      save all variable in current workspace in filename.mat
***** save filename x,y
      save variables x,y in filename.mat
***** xlsread, xlswrite
      copy data from excel sheet
**** file IO
***** read
      fid = fopen(‘filename.txt’,‘r’);
      X = fscanf(fid,‘%5d’);
      fclose(fid);
      fread
***** write
      fid = fopen(‘filename.txt’,‘w’);
      count = fwrite(fid,x);
      count returns the number of variables successfully stored.
      fclose(fid);
      fprintf
      disp
***** escape single quote
      two quotes instead of one
**** flow control
***** if
***** switch
***** for
***** while
***** break
